<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>人流ヒートマップ - AI人検出</title>
    <!-- TensorFlow.js -->
    <script src="https://unpkg.com/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <!-- COCO-SSD モデル -->
    <script src="https://unpkg.com/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.5rem;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
        }

        .btn-info {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .timelapse-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 15px;
            border-radius: 20px;
        }

        .control-group label {
            font-weight: 600;
            color: #2c3e50;
        }

        .control-group select {
            padding: 5px 10px;
            border-radius: 5px;
            border: 1px solid #ddd;
        }

        .video-container {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
        }

        .video-wrapper {
            position: relative;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            background: #000;
        }

        video, canvas {
            display: block;
            width: 640px;
            height: 480px;
            max-width: 100%;
            aspect-ratio: 4/3;
            object-fit: contain;
            border-radius: 15px;
        }

        #heatmapCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 2;
            opacity: 0.7;
        }

        .overlay-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 3;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .overlay-btn {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 15px;
            font-size: 12px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }

        .overlay-btn:hover {
            background: rgba(0, 0, 0, 0.9);
            transform: scale(1.05);
        }

        .opacity-slider {
            width: 100px;
            margin: 5px 0;
        }

        /* YouTube風フルスクリーンボタン */
        .video-fullscreen-btn {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            z-index: 10;
        }

        .video-fullscreen-btn:hover {
            background: rgba(0, 0, 0, 0.9);
            transform: scale(1.05);
        }

        /* フルスクリーン時のオーバーレイコントロール */
        .fullscreen-controls {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 9999;
            pointer-events: none;
        }

        .fullscreen-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            pointer-events: auto;
        }

        .fs-stat {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            min-width: 150px;
        }

        .fs-stat span:first-child {
            font-weight: bold;
            margin-right: 15px;
        }

        .fullscreen-buttons {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            pointer-events: auto;
        }

        .fs-btn {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            min-width: 100px;
        }

        .fs-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        .fs-btn:active {
            transform: scale(0.95);
        }

        /* モバイル用フルスクリーンスタイル */
        .mobile-fullscreen {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 9998 !important;
            background: black !important;
        }

        .mobile-fullscreen video,
        .mobile-fullscreen canvas {
            width: 100vw !important;
            height: 100vh !important;
            object-fit: cover !important;
        }

        body.mobile-fullscreen-active {
            overflow: hidden !important;
        }

        html.mobile-fullscreen-active {
            overflow: hidden !important;
        }

        .label {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 14px;
            backdrop-filter: blur(5px);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #ffffff, #f8f9fa);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .legend {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 15px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid white;
        }

        .status {
            text-align: center;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 10px;
            font-weight: 600;
        }

        .status.success {
            background: linear-gradient(135deg, #d4edda, #c3e6cb);
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: linear-gradient(135deg, #f8d7da, #f5c6cb);
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
                max-width: 100%;
            }
            
            h1 {
                font-size: 1.8rem;
                margin-bottom: 20px;
            }
            
            .controls {
                gap: 10px;
                margin-bottom: 20px;
            }
            
            .btn {
                padding: 10px 16px;
                font-size: 14px;
            }
            
            .timelapse-controls {
                flex-direction: column;
                gap: 10px;
                margin-bottom: 15px;
            }
            
            .control-group {
                padding: 8px 12px;
            }
            
            video, canvas {
                width: 100%;
                height: auto;
                max-height: 70vh;
            }
            
            .stats {
                grid-template-columns: repeat(2, 1fr);
                gap: 15px;
                margin-top: 20px;
            }
            
            .stat-card {
                padding: 15px;
            }
            
            .stat-number {
                font-size: 1.5rem;
            }
        }
        
        /* 横画面（ランドスケープ）対応 */
        @media (max-width: 768px) and (orientation: landscape) {
            .container {
                padding: 10px;
            }
            
            h1 {
                font-size: 1.5rem;
                margin-bottom: 15px;
            }
            
            .controls {
                margin-bottom: 15px;
            }
            
            .timelapse-controls {
                flex-direction: row;
                justify-content: center;
                flex-wrap: wrap;
                margin-bottom: 10px;
            }
            
            video, canvas {
                max-height: 50vh;
            }
            
            .stats {
                grid-template-columns: repeat(4, 1fr);
                gap: 10px;
                margin-top: 15px;
            }
            
            .legend {
                gap: 15px;
                margin-top: 15px;
            }
        }
        
        /* さらに小さなデバイス対応 */
        @media (max-width: 480px) {
            .container {
                padding: 10px;
            }
            
            .btn {
                padding: 8px 12px;
                font-size: 13px;
            }
            
            .controls {
                gap: 8px;
            }
            
            .stats {
                grid-template-columns: 1fr 1fr;
            }
            
            .legend {
                flex-direction: column;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🔥 人流ヒートマップ分析システム</h1>
        
        <div id="status" class="status" style="display: none;"></div>
        
        <div class="controls">
            <button id="startBtn" class="btn btn-primary">📹 AI人検出開始</button>
            <button id="demoBtn" class="btn btn-info">🎬 デモモード</button>
            <button id="stopBtn" class="btn btn-secondary" disabled>⏹️ 停止</button>
            <button id="switchCameraBtn" class="btn btn-info" disabled>🔄 カメラ切替</button>
            <button id="resetBtn" class="btn btn-info">🔄 リセット</button>
            <button id="recordBtn" class="btn btn-info" disabled>🔴 記録開始</button>
            <button id="downloadVideoBtn" class="btn btn-info" disabled>🎥 タイムラプス動画保存</button>
            <button id="fullscreenBtn" class="btn btn-info" disabled>🔍 全画面表示</button>
        </div>

        <div class="timelapse-controls">
            <div class="control-group">
                <label>記録間隔:</label>
                <select id="recordInterval">
                    <option value="100">0.1秒 (最高速・滑らか)</option>
                    <option value="250" selected>0.25秒 (高速・滑らか)</option>
                    <option value="500">0.5秒 (標準)</option>
                    <option value="1000">1秒 (低速)</option>
                    <option value="2000">2秒 (超低速)</option>
                </select>
            </div>
            <div class="control-group">
                <label>再生速度:</label>
                <select id="playbackSpeed">
                    <option value="5">5x (遅い)</option>
                    <option value="10" selected>10x (標準)</option>
                    <option value="20">20x (高速)</option>
                    <option value="30">30x (超高速)</option>
                    <option value="50">50x (最高速)</option>
                </select>
            </div>
            <div class="control-group">
                <label>動画品質:</label>
                <select id="videoQuality">
                    <option value="1">最高品質 (全フレーム, 8fps)</option>
                    <option value="2">高品質 (2フレームごと, 5fps)</option>
                    <option value="3" selected>標準 (3フレームごと, 3fps)</option>
                    <option value="4">軽量 (4フレームごと, 2fps)</option>
                    <option value="5">超軽量 (5フレームごと, 2fps)</option>
                </select>
            </div>
        </div>

        <div class="video-container">
            <div class="video-wrapper">
                <video id="video" autoplay muted playsinline></video>
                <canvas id="heatmapCanvas"></canvas>
                <div class="label">ライブ映像 + AI人検出ヒートマップ</div>
                <div class="overlay-controls">
                    <button id="toggleHeatmap" class="overlay-btn">🔥 ON</button>
                    <input type="range" id="opacitySlider" class="opacity-slider" min="0" max="100" value="70">
                    <span style="color: white; font-size: 10px; text-align: center;">透明度</span>
                </div>
                <button id="videoFullscreenBtn" class="video-fullscreen-btn" style="display: none;">⛶</button>
            </div>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(0, 0, 255, 0.3);"></div>
                <span>低密度</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(0, 255, 0, 0.5);"></div>
                <span>中密度</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(255, 255, 0, 0.7);"></div>
                <span>高密度</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(255, 0, 0, 0.8);"></div>
                <span>最高密度</span>
            </div>
        </div>

        <div class="stats">
            <div class="stat-card">
                <div id="totalDetections" class="stat-number">0</div>
                <div class="stat-label">総検出数</div>
            </div>
            <div class="stat-card">
                <div id="currentPeople" class="stat-number">0</div>
                <div class="stat-label">現在の人数</div>
            </div>
            <div class="stat-card">
                <div id="peakActivity" class="stat-number">0</div>
                <div class="stat-label">ピーク活動</div>
            </div>
            <div class="stat-card">
                <div id="aiStatus" class="stat-number">読込中</div>
                <div class="stat-label">AI状態</div>
            </div>
            <div class="stat-card">
                <div id="recordingTime" class="stat-number">00:00</div>
                <div class="stat-label">記録時間</div>
            </div>
            <div class="stat-card">
                <div id="recordedFrames" class="stat-number">0</div>
                <div class="stat-label">記録フレーム</div>
            </div>
            <div class="stat-card">
                <div id="timelapseInfo" class="stat-number">1:1</div>
                <div class="stat-label">タイムラプス比率</div>
            </div>
        </div>
    </div>

    <!-- フルスクリーン時のオーバーレイコントロール -->
    <div id="fullscreenControls" class="fullscreen-controls" style="display: none;">
        <div class="fullscreen-info">
            <div class="fs-stat">
                <span>現在の人数:</span>
                <span id="fsCurrentPeople">0</span>
            </div>
            <div class="fs-stat">
                <span>記録時間:</span>
                <span id="fsRecordingTime">00:00</span>
            </div>
            <div class="fs-stat">
                <span>記録状態:</span>
                <span id="fsRecordingStatus">停止中</span>
            </div>
        </div>
        <div class="fullscreen-buttons">
            <button id="fsRecordBtn" class="fs-btn">🔴 記録開始</button>
            <button id="fsStopBtn" class="fs-btn">⏹️ 停止</button>
            <button id="fsSwitchBtn" class="fs-btn">🔄 カメラ切替</button>
            <button id="fsExitBtn" class="fs-btn">❌ 終了</button>
        </div>
    </div>

    <script>
        class PeopleFlowHeatmap {
            constructor() {
                this.video = document.getElementById('video');
                this.canvas = document.getElementById('heatmapCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // 統計要素
                this.totalDetections = document.getElementById('totalDetections');
                this.currentPeople = document.getElementById('currentPeople');
                this.peakActivity = document.getElementById('peakActivity');
                this.aiStatus = document.getElementById('aiStatus');
                this.status = document.getElementById('status');
                
                // ボタン
                this.startBtn = document.getElementById('startBtn');
                this.demoBtn = document.getElementById('demoBtn');
                this.stopBtn = document.getElementById('stopBtn');
                this.switchCameraBtn = document.getElementById('switchCameraBtn');
                this.resetBtn = document.getElementById('resetBtn');
                this.recordBtn = document.getElementById('recordBtn');
                this.downloadVideoBtn = document.getElementById('downloadVideoBtn');
                this.fullscreenBtn = document.getElementById('fullscreenBtn');
                this.videoFullscreenBtn = document.getElementById('videoFullscreenBtn');
                
                // フルスクリーン時のコントロール
                this.fullscreenControls = document.getElementById('fullscreenControls');
                this.fsRecordBtn = document.getElementById('fsRecordBtn');
                this.fsStopBtn = document.getElementById('fsStopBtn');
                this.fsSwitchBtn = document.getElementById('fsSwitchBtn');
                this.fsExitBtn = document.getElementById('fsExitBtn');
                this.videoWrapper = document.querySelector('.video-wrapper');
                
                // フルスクリーン時の統計表示
                this.fsCurrentPeople = document.getElementById('fsCurrentPeople');
                this.fsRecordingTime = document.getElementById('fsRecordingTime');
                this.fsRecordingStatus = document.getElementById('fsRecordingStatus');
                
                // 記録関連要素
                this.recordingTime = document.getElementById('recordingTime');
                this.recordedFrames = document.getElementById('recordedFrames');
                
                // UI要素
                this.toggleHeatmapBtn = document.getElementById('toggleHeatmap');
                this.opacitySlider = document.getElementById('opacitySlider');
                
                // タイムラプス制御要素
                this.recordIntervalSelect = document.getElementById('recordInterval');
                this.playbackSpeedSelect = document.getElementById('playbackSpeed');
                this.videoQualitySelect = document.getElementById('videoQuality');
                this.timelapseInfo = document.getElementById('timelapseInfo');
                
                // データ管理
                this.heatmapData = {};
                this.animationId = null;
                this.stream = null;
                
                // モード管理
                this.isDemoMode = false;
                this.demoCanvas = null;
                
                // ヒートマップ設定
                this.heatmapEnabled = true;
                this.heatmapOpacity = 0.7;
                
                // 統計
                this.stats = {
                    totalDetections: 0,
                    currentPeople: 0,
                    peakActivity: 0,
                    startTime: null
                };
                
                // AI検出
                this.model = null;
                this.modelLoaded = false;
                this.detectionCanvas = null;
                this.detectionCtx = null;
                
                // タイムラプス記録
                this.isRecording = false;
                this.recordingStartTime = null;
                this.heatmapHistory = [];
                this.recordingInterval = 500;
                this.lastRecordTime = 0;
                this.playbackSpeed = 10;
                
                // 動画記録用
                this.mediaRecorder = null;
                this.recordedChunks = [];
                this.videoFrames = [];
                this.cameraFrames = [];
                this.lastCameraFrameTime = 0;
                
                // カメラの準備状態
                this.videoReady = false;
                this.currentFacingMode = 'environment';
                
                // フルスクリーン関連
                this.isMobileFullscreen = false;
                this.originalViewport = undefined;
                
                // 画角スケール比（デフォルト値）
                this.scaleX = 1.0;
                this.scaleY = 1.0;
                
                this.setupCanvas();
                this.loadAIModel();
                this.bindEvents();
                this.startStatsUpdater();
                this.updateTimelapseInfo();
                
                // 初期ステータスメッセージを表示
                this.showStatus('AI人検出システム準備中...', 'success');
            }
            
            adjustCanvasToVideo() {
                // ビデオの実際のサイズを取得
                const videoWidth = this.video.videoWidth || 640;
                const videoHeight = this.video.videoHeight || 480;
                
                console.log(`📹 ビデオサイズ検出: ${videoWidth}x${videoHeight}`);
                
                // キャンバスサイズをビデオサイズに合わせて調整
                this.canvas.width = videoWidth;
                this.canvas.height = videoHeight;
                this.detectionCanvas.width = videoWidth;
                this.detectionCanvas.height = videoHeight;
                
                // スケール比を保存（ヒートマップ座標計算用）
                this.scaleX = videoWidth / 640;
                this.scaleY = videoHeight / 480;
                
                // CSSでの表示サイズは既存のレスポンシブ設定を維持
                this.showStatus(`画角調整完了: ${videoWidth}x${videoHeight} (スケール: ${this.scaleX.toFixed(2)}x${this.scaleY.toFixed(2)})`, 'success');
            }
            
            setupCanvas() {
                this.canvas.width = 640;
                this.canvas.height = 480;
                
                // AI検出用の隠しキャンバス
                this.detectionCanvas = document.createElement('canvas');
                this.detectionCanvas.width = 640;
                this.detectionCanvas.height = 480;
                this.detectionCtx = this.detectionCanvas.getContext('2d');
            }
            
            async loadAIModel() {
                try {
                    this.aiStatus.textContent = '読込中...';
                    
                    // ライブラリの読み込み待機
                    await this.waitForLibraries();
                    
                    // TensorFlow.jsの初期化を待つ
                    console.log('TensorFlow.js loading...');
                    await tf.ready();
                    console.log('TensorFlow.js ready');
                    
                    // COCO-SSDモデルの読み込み
                    console.log('Loading COCO-SSD model...');
                    this.model = await cocoSsd.load();
                    this.modelLoaded = true;
                    this.aiStatus.textContent = '準備完了';
                    this.aiStatus.style.color = '#4CAF50';
                    this.showStatus('AI人検出モデルが読み込まれました', 'success');
                    console.log('COCO-SSD model loaded successfully');
                } catch (error) {
                    console.error('AI モデル読み込みエラー:', error);
                    this.handleModelLoadError();
                }
            }
            
            async waitForLibraries() {
                const maxWait = 10000;
                const startTime = Date.now();
                
                return new Promise((resolve, reject) => {
                    const checkLibraries = () => {
                        if (typeof tf !== 'undefined' && typeof cocoSsd !== 'undefined') {
                            console.log('All libraries loaded successfully');
                            resolve();
                        } else if (Date.now() - startTime > maxWait) {
                            reject(new Error('Library loading timeout'));
                        } else {
                            console.log('Waiting for libraries...', {
                                tf: typeof tf !== 'undefined',
                                cocoSsd: typeof cocoSsd !== 'undefined'
                            });
                            setTimeout(checkLibraries, 500);
                        }
                    };
                    checkLibraries();
                });
            }
            
            handleModelLoadError() {
                this.aiStatus.textContent = 'オフライン';
                this.aiStatus.style.color = '#ff9800';
                this.showStatus('AIライブラリの読み込みに失敗しました。基本機能は動作します。', 'error');
                
                this.startBtn.textContent = '📹 カメラ開始（AI無効）';
                this.startBtn.disabled = false;
            }
            
            bindEvents() {
                this.startBtn.addEventListener('click', () => this.startCamera());
                this.demoBtn.addEventListener('click', () => this.startDemo());
                this.stopBtn.addEventListener('click', () => this.stopCamera());
                this.switchCameraBtn.addEventListener('click', () => this.switchCamera());
                this.resetBtn.addEventListener('click', () => this.resetData());
                this.recordBtn.addEventListener('click', () => this.toggleRecording());
                this.downloadVideoBtn.addEventListener('click', () => this.downloadVideo());
                this.fullscreenBtn.addEventListener('click', () => this.toggleFullscreen());
                this.videoFullscreenBtn.addEventListener('click', () => this.toggleFullscreen());
                
                // フルスクリーン時のコントロール
                this.fsRecordBtn.addEventListener('click', () => this.toggleRecording());
                this.fsStopBtn.addEventListener('click', () => this.stopCamera());
                this.fsSwitchBtn.addEventListener('click', () => this.switchCamera());
                this.fsExitBtn.addEventListener('click', () => this.exitFullscreen());
                
                // フルスクリーン状態の監視
                document.addEventListener('fullscreenchange', () => this.handleFullscreenChange());
                document.addEventListener('webkitfullscreenchange', () => this.handleFullscreenChange());
                document.addEventListener('mozfullscreenchange', () => this.handleFullscreenChange());
                document.addEventListener('msfullscreenchange', () => this.handleFullscreenChange());
                
                this.toggleHeatmapBtn.addEventListener('click', () => this.toggleHeatmap());
                this.opacitySlider.addEventListener('input', (e) => {
                    this.heatmapOpacity = e.target.value / 100;
                    this.updateHeatmapOpacity();
                });
                
                // タイムラプス制御イベント
                this.recordIntervalSelect.addEventListener('change', (e) => {
                    this.recordingInterval = parseInt(e.target.value);
                    this.updateTimelapseInfo();
                });
                this.playbackSpeedSelect.addEventListener('change', (e) => {
                    this.playbackSpeed = parseInt(e.target.value);
                    this.updateTimelapseInfo();
                });
                this.videoQualitySelect.addEventListener('change', () => {
                    this.updateTimelapseInfo();
                });
            }
            
            getQualitySettings() {
                const quality = parseInt(this.videoQualitySelect.value);
                const settings = {
                    1: { frameSkip: 1, fps: 8 },
                    2: { frameSkip: 2, fps: 5 },
                    3: { frameSkip: 3, fps: 3 },
                    4: { frameSkip: 4, fps: 2 },
                    5: { frameSkip: 5, fps: 2 }
                };
                return settings[quality] || settings[3];
            }
            
            updateTimelapseInfo() {
                const recordInterval = parseInt(this.recordIntervalSelect.value);
                const playbackSpeed = parseInt(this.playbackSpeedSelect.value);
                const { frameSkip, fps: videoFps } = this.getQualitySettings();
                
                const realTimePerFrame = recordInterval;
                const videoTimePerFrame = 1000 / videoFps;
                const compressionRatio = Math.round((realTimePerFrame * playbackSpeed) / videoTimePerFrame);
                
                this.timelapseInfo.textContent = `${compressionRatio}:1`;
                
                const tenMinutesMs = 10 * 60 * 1000;
                const framesIn10Min = Math.floor(tenMinutesMs / recordInterval);
                const videoDurationSeconds = Math.round(framesIn10Min / videoFps);
                
                this.timelapseInfo.title = `10分記録→${videoDurationSeconds}秒動画`;
            }
            
            showStatus(message, type = 'success') {
                this.status.textContent = message;
                this.status.className = `status ${type}`;
                
                // ステータスを常に表示状態に保つ
                this.status.style.display = 'block';
                
                // 自動非表示はしない（必要に応じて手動で非表示にする）
            }
            
            async startCamera() {
                try {
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const videoDevices = devices.filter(device => device.kind === 'videoinput');
                    
                    if (videoDevices.length === 0) {
                        throw new Error('カメラデバイスが見つかりませんでした');
                    }
                    
                    this.showStatus('カメラへのアクセス許可を求めています...', 'success');
                    
                    const constraints = {
                        video: {
                            width: { ideal: 640, min: 320 },
                            height: { ideal: 480, min: 240 },
                            frameRate: { ideal: 30, min: 15 },
                            facingMode: { ideal: this.currentFacingMode },
                            aspectRatio: { ideal: 4/3 }
                        },
                        audio: false
                    };
                    
                    this.stream = await navigator.mediaDevices.getUserMedia(constraints);
                    this.video.srcObject = this.stream;
                    this.stats.startTime = Date.now();
                    this.isDemoMode = false;
                    
                    this.video.addEventListener('loadeddata', () => {
                        this.videoReady = true;
                        this.adjustCanvasToVideo();
                        this.startDetection();
                    });
                    
                    this.video.addEventListener('playing', () => {
                        this.showStatus('カメラ映像が表示されています。記録を開始できます。', 'success');
                    });
                    
                    this.startBtn.disabled = true;
                    this.demoBtn.disabled = true;
                    this.stopBtn.disabled = false;
                    this.switchCameraBtn.disabled = false;
                    this.recordBtn.disabled = false;
                    this.fullscreenBtn.disabled = false;
                    this.videoFullscreenBtn.style.display = 'flex';
                    
                    if (this.modelLoaded) {
                        this.showStatus('AI人検出カメラ開始 - 記録ボタンでタイムラプス記録を開始できます', 'success');
                    } else {
                        this.showStatus('カメラ開始（AI機能は無効） - 記録ボタンでタイムラプス記録を開始できます', 'success');
                    }
                } catch (error) {
                    console.error('カメラアクセスエラー:', error);
                    this.showStatus('カメラにアクセスできませんでした。デモモードをお試しください。', 'error');
                }
            }
            
            startDemo() {
                this.isDemoMode = true;
                this.videoReady = true;
                this.stats.startTime = Date.now();
                this.createDemoVideo();
                this.startDetection();
                
                this.startBtn.disabled = true;
                this.demoBtn.disabled = true;
                this.stopBtn.disabled = false;
                this.switchCameraBtn.disabled = true;
                this.recordBtn.disabled = false;
                this.fullscreenBtn.disabled = false;
                this.videoFullscreenBtn.style.display = 'flex';
                
                this.showStatus('デモモード開始 - 仮想的な人流データを表示中', 'success');
            }
            
            createDemoVideo() {
                const demoCanvas = document.createElement('canvas');
                demoCanvas.width = 640;
                demoCanvas.height = 480;
                const demoCtx = demoCanvas.getContext('2d');
                
                const gradient = demoCtx.createLinearGradient(0, 0, 640, 480);
                gradient.addColorStop(0, '#e3f2fd');
                gradient.addColorStop(1, '#bbdefb');
                demoCtx.fillStyle = gradient;
                demoCtx.fillRect(0, 0, 640, 480);
                
                demoCtx.fillStyle = '#1976d2';
                demoCtx.font = 'bold 24px Arial';
                demoCtx.textAlign = 'center';
                demoCtx.fillText('デモモード - 仮想空間', 320, 50);
                
                this.video.style.display = 'none';
                const imgElement = document.createElement('img');
                imgElement.src = demoCanvas.toDataURL();
                imgElement.style.position = 'absolute';
                imgElement.style.top = '0';
                imgElement.style.left = '0';
                imgElement.style.zIndex = '1';
                imgElement.style.width = '640px';
                imgElement.style.height = '480px';
                this.video.parentNode.insertBefore(imgElement, this.video);
                this.demoCanvas = imgElement;
            }
            
            async switchCamera() {
                if (!this.stream) return;
                
                try {
                    this.showStatus('カメラを切り替え中...', 'success');
                    
                    // 現在のストリームを停止
                    this.stream.getTracks().forEach(track => track.stop());
                    
                    // facingModeを切り替え
                    this.currentFacingMode = this.currentFacingMode === 'user' ? 'environment' : 'user';
                    
                    // 新しいカメラで再開
                    const constraints = {
                        video: {
                            width: { ideal: 640, min: 320 },
                            height: { ideal: 480, min: 240 },
                            frameRate: { ideal: 30, min: 15 },
                            facingMode: { ideal: this.currentFacingMode },
                            aspectRatio: { ideal: 4/3 }
                        },
                        audio: false
                    };
                    
                    this.stream = await navigator.mediaDevices.getUserMedia(constraints);
                    this.video.srcObject = this.stream;
                    
                    // カメラ切り替え後に画角を再調整
                    this.video.addEventListener('loadeddata', () => {
                        this.adjustCanvasToVideo();
                    }, { once: true });
                    
                    const cameraType = this.currentFacingMode === 'user' ? '内カメラ' : '外カメラ';
                    this.showStatus(`${cameraType}に切り替えました`, 'success');
                    
                } catch (error) {
                    console.error('カメラ切り替えエラー:', error);
                    this.showStatus('カメラの切り替えに失敗しました', 'error');
                    
                    // 元のカメラに戻す
                    this.currentFacingMode = this.currentFacingMode === 'user' ? 'environment' : 'user';
                }
            }
            
            stopCamera() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
                
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                    this.stream = null;
                }
                
                if (this.demoCanvas) {
                    this.demoCanvas.remove();
                    this.demoCanvas = null;
                }
                
                this.video.style.display = 'block';
                this.videoReady = false;
                this.isDemoMode = false;
                
                if (this.isRecording) {
                    this.stopRecording();
                }
                
                this.startBtn.disabled = false;
                this.demoBtn.disabled = false;
                this.stopBtn.disabled = true;
                this.switchCameraBtn.disabled = true;
                this.recordBtn.disabled = true;
                this.fullscreenBtn.disabled = true;
                this.videoFullscreenBtn.style.display = 'none';
                
                if (this.heatmapHistory.length > 0) {
                    this.downloadVideoBtn.disabled = false;
                }
                
                this.showStatus('停止されました', 'success');
            }
            
            resetData() {
                this.heatmapData = {};
                this.heatmapHistory = [];
                this.videoFrames = [];
                this.cameraFrames = [];
                this.stats = {
                    totalDetections: 0,
                    currentPeople: 0,
                    peakActivity: 0,
                    startTime: this.stats.startTime
                };
                
                this.isRecording = false;
                this.recordingStartTime = null;
                
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.updateStatsDisplay();
                
                this.recordBtn.textContent = '🔴 記録開始';
                this.recordBtn.disabled = !this.videoReady;
                this.downloadVideoBtn.disabled = true;
                
                this.showStatus('データがリセットされました', 'success');
            }
            
            toggleHeatmap() {
                this.heatmapEnabled = !this.heatmapEnabled;
                this.toggleHeatmapBtn.textContent = this.heatmapEnabled ? '🔥 ON' : '🔥 OFF';
                this.updateHeatmapOpacity();
            }
            
            updateHeatmapOpacity() {
                if (this.heatmapEnabled) {
                    this.canvas.style.opacity = this.heatmapOpacity;
                    this.canvas.style.display = 'block';
                } else {
                    this.canvas.style.display = 'none';
                }
            }
            
            toggleRecording() {
                if (!this.isRecording) {
                    this.startRecording();
                } else {
                    this.stopRecording();
                }
            }
            
            startRecording() {
                // UI設定を取得
                this.recordingInterval = parseInt(this.recordIntervalSelect.value);
                this.playbackSpeed = parseInt(this.playbackSpeedSelect.value);
                
                this.isRecording = true;
                this.recordingStartTime = Date.now();
                this.heatmapHistory = [];
                this.videoFrames = [];
                this.cameraFrames = [];
                this.lastRecordTime = 0;
                this.lastCameraFrameTime = 0;
                
                this.recordBtn.textContent = '⏹️ 記録停止';
                
                const ratio = this.timelapseInfo.textContent;
                this.showStatus(`タイムラプス記録中... 間隔:${this.recordingInterval}ms, 圧縮比:${ratio}`, 'success');
            }
            
            stopRecording() {
                this.isRecording = false;
                this.recordBtn.textContent = '🔴 記録開始';
                
                if (this.heatmapHistory.length > 0) {
                    this.downloadVideoBtn.disabled = false;
                    
                    const recordDuration = Math.floor((Date.now() - this.recordingStartTime) / 1000);
                    const { fps: videoFps } = this.getQualitySettings();
                    const expectedVideoDuration = Math.floor(this.heatmapHistory.length / videoFps);
                    const compressionRatio = this.timelapseInfo.textContent;
                    
                    this.showStatus(`記録完了！${recordDuration}秒→約${expectedVideoDuration}秒動画 (圧縮比${compressionRatio}) - タイムラプス動画を保存できます`, 'success');
                } else {
                    this.showStatus('記録データがありません - 記録を開始してください', 'error');
                }
            }
            
            recordHeatmapFrame() {
                if (!this.isRecording) return;
                
                const currentTime = Date.now();
                
                if (currentTime - this.lastRecordTime >= this.recordingInterval) {
                    const frameData = {
                        timestamp: currentTime - this.recordingStartTime,
                        heatmapData: JSON.parse(JSON.stringify(this.heatmapData)),
                        stats: {
                            currentPeople: this.stats.currentPeople,
                            totalDetections: this.stats.totalDetections
                        }
                    };
                    
                    this.heatmapHistory.push(frameData);
                    this.lastRecordTime = currentTime;
                    
                    this.recordVideoFrame();
                    this.recordCameraFrame();
                }
            }
            
            recordVideoFrame() {
                if (!this.isRecording) return;
                
                try {
                    // ヒートマップキャンバスが空でないかチェック
                    const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                    const pixels = imageData.data;
                    let hasContent = false;
                    
                    // 透明でないピクセルがあるかチェック
                    for (let i = 3; i < pixels.length; i += 4) {
                        if (pixels[i] > 0) { // アルファチャンネルが0より大きい
                            hasContent = true;
                            break;
                        }
                    }
                    
                    const heatmapImageData = this.canvas.toDataURL('image/png');
                    this.videoFrames.push({
                        timestamp: Date.now() - this.recordingStartTime,
                        imageData: heatmapImageData,
                        frameIndex: this.videoFrames.length,
                        hasContent: hasContent
                    });
                    
                    console.log(`🔥 ヒートマップフレーム ${this.videoFrames.length} 記録完了 - コンテンツ有:${hasContent}`);
                } catch (error) {
                    console.error('ヒートマップフレーム記録エラー:', error);
                }
            }
            
            recordCameraFrame() {
                if (!this.isRecording) return;
                
                const currentTime = Date.now();
                const cameraInterval = Math.max(this.recordingInterval, 250); // 最低250ms間隔に変更してより滑らかに
                
                if (currentTime - this.lastCameraFrameTime < cameraInterval) {
                    return;
                }
                
                this.lastCameraFrameTime = currentTime;
                console.log(`🎥 カメラフレーム記録試行 - デモ:${this.isDemoMode}, ビデオ準備:${this.videoReady}`);
                
                if (this.isDemoMode && this.demoCanvas) {
                    // デモモードの場合
                    try {
                        this.cameraFrames.push({
                            timestamp: currentTime - this.recordingStartTime,
                            imageData: this.demoCanvas.src,
                            frameIndex: this.cameraFrames.length,
                            isDemo: true,
                            width: 640,
                            height: 480
                        });
                        console.log(`✅ デモフレーム ${this.cameraFrames.length} 記録完了`);
                    } catch (error) {
                        console.error('❌ デモフレーム記録エラー:', error);
                    }
                } else if (!this.isDemoMode && this.videoReady) {
                    // 実際のカメラ映像の場合
                    try {
                        if (this.video && 
                            this.video.readyState >= 2 && 
                            this.video.videoWidth > 0 && 
                            this.video.videoHeight > 0) {
                            
                            const tempCanvas = document.createElement('canvas');
                            tempCanvas.width = 640;
                            tempCanvas.height = 480;
                            const tempCtx = tempCanvas.getContext('2d');
                            
                            // ビデオを描画する前に少し待機
                            setTimeout(() => {
                                try {
                                    tempCtx.drawImage(this.video, 0, 0, 640, 480);
                                    const cameraImageData = tempCanvas.toDataURL('image/png');
                                    
                                    if (cameraImageData && cameraImageData.length > 1000) {
                                        this.cameraFrames.push({
                                            timestamp: currentTime - this.recordingStartTime,
                                            imageData: cameraImageData,
                                            frameIndex: this.cameraFrames.length,
                                            videoWidth: this.video.videoWidth,
                                            videoHeight: this.video.videoHeight
                                        });
                                        console.log(`✅ リアルカメラフレーム ${this.cameraFrames.length} 記録完了`);
                                    } else {
                                        console.warn('⚠️ カメラデータが無効です');
                                    }
                                } catch (drawError) {
                                    console.error('❌ カメラ描画エラー:', drawError);
                                }
                            }, 50); // 50ms待機
                        } else {
                            console.warn(`⚠️ ビデオ準備不完了 - readyState: ${this.video.readyState}`);
                        }
                    } catch (error) {
                        console.error('❌ カメラフレーム記録エラー:', error);
                    }
                } else {
                    console.log(`⏭️ カメラフレーム記録条件不適合`);
                }
            }
            
            
            
            async downloadVideo() {
                if (this.videoFrames.length === 0) {
                    this.showStatus('動画データがありません', 'error');
                    return;
                }
                
                // 全てのカメラフレームを使用（フィルタリングを緩和）
                const allValidFrames = this.cameraFrames.filter(frame => 
                    frame && frame.imageData);
                
                // 品質設定からフレーム間引きとFPSを取得
                const { frameSkip, fps: videoFps } = this.getQualitySettings();
                const validCameraFrames = allValidFrames.filter((frame, index) => 
                    (index + 1) % frameSkip === 0);
                
                console.log(`📊 フレーム品質チェック - 総数:${this.cameraFrames.length}, 有効:${allValidFrames.length}, 間引き後:${validCameraFrames.length} (${frameSkip}フレームごと)`);
                console.log(`📊 ヒートマップフレーム数:${this.videoFrames.length}`);
                
                // デバッグ: 選択されたフレーム番号を表示
                const selectedFrameIndexes = allValidFrames
                    .map((frame, index) => (index + 1) % frameSkip === 0 ? index + 1 : null)
                    .filter(index => index !== null);
                console.log(`🎯 選択フレーム番号: ${selectedFrameIndexes.slice(0, 10).join(', ')}${selectedFrameIndexes.length > 10 ? '...' : ''}`);
                
                const compressionRatio = this.timelapseInfo.textContent;
                
                this.showStatus(`タイムラプス動画生成中... (${videoFps}fps, ${compressionRatio}圧縮)`, 'success');
                
                try {
                    // すべてのフレームを準備してから記録する新方式
                    const canvas = document.createElement('canvas');
                    canvas.width = this.canvas.width;
                    canvas.height = this.canvas.height;
                    const ctx = canvas.getContext('2d');
                    
                    // 全フレームを事前準備
                    const preparedFrames = [];
                    this.showStatus('フレーム準備中...', 'success');
                    
                    for (let i = 0; i < validCameraFrames.length; i++) {
                        try {
                            // 背景クリア
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            
                            // デフォルト背景を設定
                            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                            gradient.addColorStop(0, '#e3f2fd');
                            gradient.addColorStop(1, '#bbdefb');
                            ctx.fillStyle = gradient;
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                            
                            let cameraDrawn = false;
                            
                            // カメラ映像を描画
                            const cameraFrame = validCameraFrames[i];
                            if (cameraFrame && cameraFrame.imageData) {
                                try {
                                    const cameraImg = new Image();
                                    await new Promise((resolve) => {
                                        cameraImg.onload = () => {
                                            try {
                                                if (cameraImg.width > 0 && cameraImg.height > 0) {
                                                    ctx.drawImage(cameraImg, 0, 0, canvas.width, canvas.height);
                                                    cameraDrawn = true;
                                                }
                                            } catch (error) {
                                                console.error('カメラ描画エラー:', error);
                                            }
                                            resolve();
                                        };
                                        cameraImg.onerror = () => resolve();
                                        cameraImg.src = cameraFrame.imageData;
                                    });
                                } catch (error) {
                                    console.error('カメラ処理エラー:', error);
                                }
                            }
                            
                            // デフォルト表示
                            if (!cameraDrawn) {
                                ctx.fillStyle = '#1976d2';
                                ctx.font = 'bold 24px Arial';
                                ctx.textAlign = 'center';
                                ctx.fillText('人流ヒートマップ', canvas.width / 2, canvas.height / 2);
                                ctx.textAlign = 'left';
                            }
                            
                            // ヒートマップ重ね合わせ
                            if (this.videoFrames.length > 0) {
                                const targetTime = cameraFrame.timestamp;
                                let closestHeatmapFrame = this.videoFrames[0];
                                let minTimeDiff = Math.abs(targetTime - closestHeatmapFrame.timestamp);
                                
                                for (const heatmapFrame of this.videoFrames) {
                                    const timeDiff = Math.abs(targetTime - heatmapFrame.timestamp);
                                    if (timeDiff < minTimeDiff) {
                                        minTimeDiff = timeDiff;
                                        closestHeatmapFrame = heatmapFrame;
                                    }
                                }
                                
                                if (closestHeatmapFrame && closestHeatmapFrame.imageData) {
                                    try {
                                        const heatmapImg = new Image();
                                        await new Promise((resolve) => {
                                            heatmapImg.onload = () => {
                                                try {
                                                    ctx.globalAlpha = 0.8;
                                                    ctx.drawImage(heatmapImg, 0, 0, canvas.width, canvas.height);
                                                    ctx.globalAlpha = 1.0;
                                                } catch (error) {
                                                    console.error('ヒートマップ描画エラー:', error);
                                                }
                                                resolve();
                                            };
                                            heatmapImg.onerror = () => resolve();
                                            heatmapImg.src = closestHeatmapFrame.imageData;
                                        });
                                    } catch (error) {
                                        console.error('ヒートマップ処理エラー:', error);
                                    }
                                }
                            }
                            
                            // キャプション描画
                            const captionX = 10, captionY = 10, captionW = 400, captionH = 140;
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                            ctx.fillRect(captionX, captionY, captionW, captionH);
                            
                            ctx.fillStyle = 'white';
                            ctx.font = 'bold 16px Arial';
                            ctx.textBaseline = 'top';
                            ctx.fillText('🎬 タイムラプス動画', captionX + 10, captionY + 10);
                            
                            ctx.font = 'bold 14px Arial';
                            const { frameSkip: displayFrameSkip } = this.getQualitySettings();
                            const originalFrameIndex = ((i + 1) * displayFrameSkip);
                            ctx.fillText(`Frame: ${i + 1}/${validCameraFrames.length} (元:${originalFrameIndex})`, captionX + 10, captionY + 35);
                            
                            const timestamp = cameraFrame.timestamp;
                            const minutes = Math.floor(timestamp / 60000);
                            const seconds = Math.floor((timestamp % 60000) / 1000);
                            ctx.fillText(`Time: ${minutes}:${seconds.toString().padStart(2, '0')}`, captionX + 10, captionY + 60);
                            ctx.fillText(`圧縮比: ${compressionRatio}`, captionX + 10, captionY + 85);
                            ctx.fillText(`品質: ${displayFrameSkip}フレームごと, ${videoFps}fps`, captionX + 10, captionY + 110);
                            
                            // フレームを保存
                            const frameImageData = canvas.toDataURL('image/png');
                            preparedFrames.push(frameImageData);
                            
                            const progress = Math.round(((i + 1) / validCameraFrames.length) * 50);
                            this.showStatus(`フレーム準備中... ${progress}% (${i + 1}/${validCameraFrames.length})`, 'success');
                            
                        } catch (error) {
                            console.error(`フレーム ${i} 準備エラー:`, error);
                        }
                    }
                    
                    console.log(`📊 フレーム準備完了: ${preparedFrames.length}フレーム`);
                    this.showStatus('動画記録開始...', 'success');
                    
                    // MediaRecorderで記録
                    const stream = canvas.captureStream(videoFps);
                    const mediaRecorder = new MediaRecorder(stream, {
                        mimeType: 'video/webm',
                        videoBitsPerSecond: 2500000
                    });
                    
                    const recordedChunks = [];
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            recordedChunks.push(event.data);
                        }
                    };
                    
                    mediaRecorder.onstop = () => {
                        const blob = new Blob(recordedChunks, { type: 'video/webm' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `people-flow-timelapse-${compressionRatio.replace(':', 'to')}-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.webm`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        
                        this.showStatus(`タイムラプス動画をダウンロードしました (${compressionRatio}圧縮)`, 'success');
                    };
                    
                    mediaRecorder.start();
                    
                    // 準備したフレームを順次描画
                    const frameInterval = 1000 / videoFps;
                    for (let i = 0; i < preparedFrames.length; i++) {
                        const img = new Image();
                        await new Promise((resolve) => {
                            img.onload = () => {
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                                
                                const progress = Math.round(50 + ((i + 1) / preparedFrames.length) * 50);
                                this.showStatus(`動画記録中... ${progress}% (${i + 1}/${preparedFrames.length})`, 'success');
                                resolve();
                            };
                            img.onerror = () => resolve();
                            img.src = preparedFrames[i];
                        });
                        
                        // 確実にフレームを記録するため適切な間隔で待機
                        await new Promise(resolve => setTimeout(resolve, frameInterval));
                    }
                    
                    // 記録完了
                    setTimeout(() => {
                        mediaRecorder.stop();
                        stream.getTracks().forEach(track => track.stop());
                        console.log(`🎬 動画記録完了: ${preparedFrames.length}フレーム`);
                    }, 1000);
                    
                } catch (error) {
                    console.error('タイムラプス動画生成エラー:', error);
                    this.showStatus('タイムラプス生成に失敗しました', 'error');
                }
            }
            
            startDetection() {
                const detect = async () => {
                    if (this.isDemoMode) {
                        this.detectMotion();
                        this.updateHeatmap();
                        this.recordHeatmapFrame();
                    } else if (this.videoReady) {
                        if (this.modelLoaded) {
                            await this.detectPeopleWithAI();
                        } else {
                            this.detectMotion();
                        }
                        this.updateHeatmap();
                        this.recordHeatmapFrame();
                    }
                    this.animationId = requestAnimationFrame(detect);
                };
                detect();
            }
            
            detectMotion() {
                const currentTime = Date.now();
                const mockDetections = this.generateMockDetections();
                
                this.stats.currentPeople = mockDetections.length;
                this.stats.totalDetections += mockDetections.length;
                
                if (mockDetections.length > this.stats.peakActivity) {
                    this.stats.peakActivity = mockDetections.length;
                }
                
                mockDetections.forEach(detection => {
                    const baseGridSize = 15;
                    const gridSize = Math.max(baseGridSize * Math.min(this.scaleX, this.scaleY), 10); // スケールに応じて調整
                    const key = `${Math.floor(detection.x / gridSize)}_${Math.floor(detection.y / gridSize)}`;
                    if (!this.heatmapData[key]) {
                        this.heatmapData[key] = {
                            count: 0,
                            x: Math.floor(detection.x / gridSize) * gridSize,
                            y: Math.floor(detection.y / gridSize) * gridSize,
                            lastUpdate: currentTime
                        };
                    }
                    this.heatmapData[key].count++;
                    this.heatmapData[key].lastUpdate = currentTime;
                });
                
                Object.keys(this.heatmapData).forEach(key => {
                    const data = this.heatmapData[key];
                    const timeDiff = currentTime - data.lastUpdate;
                    if (timeDiff > 3000) {
                        const decayFactor = Math.max(0, 1 - (timeDiff - 3000) / 10000);
                        data.count *= decayFactor;
                        
                        if (data.count <= 0.1) {
                            delete this.heatmapData[key];
                        }
                    }
                });
            }
            
            generateMockDetections() {
                const detections = [];
                const time = (Date.now() - this.stats.startTime) / 1000;
                const timeOfDay = (time % 60) / 60;
                const baseActivity = Math.sin(timeOfDay * Math.PI * 2) * 0.5 + 0.5;
                const numPeople = Math.floor(baseActivity * 12) + 2;
                
                const hotspots = [
                    { x: 160, y: 200 },
                    { x: 480, y: 200 },
                    { x: 320, y: 350 },
                    { x: 100, y: 400 }
                ];
                
                for (let i = 0; i < numPeople; i++) {
                    const hotspot = hotspots[Math.floor(Math.random() * hotspots.length)];
                    const spreadRadius = 80;
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * spreadRadius;
                    
                    const x = Math.max(50, Math.min(590, hotspot.x + Math.cos(angle) * distance));
                    const y = Math.max(150, Math.min(430, hotspot.y + Math.sin(angle) * distance));
                    
                    detections.push({ x, y });
                }
                
                return detections;
            }
            
            updateHeatmap() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                Object.values(this.heatmapData).forEach(point => {
                    const intensity = Math.min(point.count / 20, 1);
                    
                    let r, g, b;
                    if (intensity < 0.25) {
                        r = 0; 
                        g = 0; 
                        b = Math.floor(255 * intensity * 4);
                    } else if (intensity < 0.5) {
                        r = 0; 
                        g = Math.floor(255 * (intensity - 0.25) * 4); 
                        b = 255 - g;
                    } else if (intensity < 0.75) {
                        r = Math.floor(255 * (intensity - 0.5) * 4); 
                        g = 255; 
                        b = 0;
                    } else {
                        r = 255; 
                        g = 255 - Math.floor(255 * (intensity - 0.75) * 4); 
                        b = 0;
                    }
                    
                    const alpha = intensity * 0.6;
                    const baseRadius = 30;
                    const radius = Math.max(baseRadius * Math.min(this.scaleX, this.scaleY), 20); // スケールに応じて半径調整
                    const gradient = this.ctx.createRadialGradient(point.x, point.y, 0, point.x, point.y, radius);
                    gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${alpha})`);
                    gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
                    this.ctx.fill();
                });
            }
            
            startStatsUpdater() {
                setInterval(() => {
                    this.updateStatsDisplay();
                }, 1000);
            }
            
            updateStatsDisplay() {
                this.totalDetections.textContent = this.stats.totalDetections.toLocaleString();
                this.currentPeople.textContent = this.stats.currentPeople;
                this.peakActivity.textContent = this.stats.peakActivity;
                
                // フルスクリーン時の統計も更新
                this.updateFullscreenStats();
                
                if (this.isRecording && this.recordingStartTime) {
                    const recordTime = Math.floor((Date.now() - this.recordingStartTime) / 1000);
                    const recordMinutes = Math.floor(recordTime / 60);
                    const recordSeconds = recordTime % 60;
                    this.recordingTime.textContent = `${recordMinutes.toString().padStart(2, '0')}:${recordSeconds.toString().padStart(2, '0')}`;
                } else if (!this.isRecording && this.heatmapHistory.length > 0) {
                    const totalDuration = Math.floor(this.heatmapHistory[this.heatmapHistory.length - 1].timestamp / 1000);
                    const totalMinutes = Math.floor(totalDuration / 60);
                    const totalSeconds = totalDuration % 60;
                    this.recordingTime.textContent = `${totalMinutes.toString().padStart(2, '0')}:${totalSeconds.toString().padStart(2, '0')}`;
                } else {
                    this.recordingTime.textContent = '00:00';
                }
                
                this.recordedFrames.textContent = this.heatmapHistory.length;
                
                if (!this.aiStatus.textContent.includes('準備完了') && !this.aiStatus.textContent.includes('エラー') && !this.aiStatus.textContent.includes('オフライン')) {
                    if (this.modelLoaded) {
                        this.aiStatus.textContent = '準備完了';
                        this.aiStatus.style.color = '#4CAF50';
                    }
                }
            }
            
            async detectPeopleWithAI() {
                try {
                    this.detectionCtx.drawImage(this.video, 0, 0, this.detectionCanvas.width, this.detectionCanvas.height);
                    
                    // より多くの検出を行うためにmaxNumBoxesを増やし、iouThresholdを調整
                    const predictions = await this.model.detect(this.detectionCanvas, 50, 0.3);
                    
                    const people = predictions.filter(prediction => 
                        prediction.class === 'person' && prediction.score > 0.3
                    );
                    
                    const detections = people.map(person => {
                        const [x, y, width, height] = person.bbox;
                        return {
                            x: x + width / 2,
                            y: y + height / 2,
                            confidence: person.score,
                            bbox: person.bbox
                        };
                    });
                    
                    this.stats.currentPeople = detections.length;
                    this.stats.totalDetections += detections.length;
                    
                    if (detections.length > this.stats.peakActivity) {
                        this.stats.peakActivity = detections.length;
                    }
                    
                    this.updateHeatmapData(detections);
                    
                    if (detections.length > 0) {
                        console.log(`${detections.length}人を検出しました`);
                    }
                    
                } catch (error) {
                    console.error('AI検出エラー:', error);
                }
            }
            
            updateHeatmapData(detections) {
                const currentTime = Date.now();
                
                detections.forEach(detection => {
                    const baseGridSize = 15;
                    const gridSize = Math.max(baseGridSize * Math.min(this.scaleX, this.scaleY), 10); // スケールに応じて調整
                    const key = `${Math.floor(detection.x / gridSize)}_${Math.floor(detection.y / gridSize)}`;
                    if (!this.heatmapData[key]) {
                        this.heatmapData[key] = {
                            count: 0,
                            x: Math.floor(detection.x / gridSize) * gridSize,
                            y: Math.floor(detection.y / gridSize) * gridSize,
                            lastUpdate: currentTime
                        };
                    }
                    this.heatmapData[key].count += detection.confidence || 1;
                    this.heatmapData[key].lastUpdate = currentTime;
                });
                
                Object.keys(this.heatmapData).forEach(key => {
                    const data = this.heatmapData[key];
                    const timeDiff = currentTime - data.lastUpdate;
                    if (timeDiff > 10000) {
                        data.count = Math.max(0, data.count - 0.05);
                        if (data.count <= 0) {
                            delete this.heatmapData[key];
                        }
                    }
                });
            }
            
            // フルスクリーン機能
            toggleFullscreen() {
                if (this.isFullscreen()) {
                    this.exitFullscreen();
                } else {
                    this.enterFullscreen();
                }
            }
            
            isFullscreen() {
                return !!(document.fullscreenElement || 
                         document.webkitFullscreenElement || 
                         document.mozFullScreenElement || 
                         document.msFullscreenElement ||
                         this.isMobileFullscreen);
            }
            
            isMobile() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            }
            
            async enterFullscreen() {
                try {
                    if (this.isMobile()) {
                        this.enterMobileFullscreen();
                    } else {
                        if (this.videoWrapper.requestFullscreen) {
                            await this.videoWrapper.requestFullscreen();
                        } else if (this.videoWrapper.webkitRequestFullscreen) {
                            await this.videoWrapper.webkitRequestFullscreen();
                        } else if (this.videoWrapper.mozRequestFullScreen) {
                            await this.videoWrapper.mozRequestFullScreen();
                        } else if (this.videoWrapper.msRequestFullscreen) {
                            await this.videoWrapper.msRequestFullscreen();
                        }
                    }
                } catch (error) {
                    console.error('フルスクリーン開始エラー:', error);
                    this.showStatus('フルスクリーンの開始に失敗しました', 'error');
                }
            }
            
            enterMobileFullscreen() {
                this.isMobileFullscreen = true;
                
                // ビューポートを保存
                const viewport = document.querySelector('meta[name=viewport]');
                if (viewport) {
                    this.originalViewport = viewport.content;
                    viewport.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no';
                }
                
                // スクロール禁止
                document.body.classList.add('mobile-fullscreen-active');
                document.documentElement.classList.add('mobile-fullscreen-active');
                
                // フルスクリーンスタイル適用
                this.videoWrapper.classList.add('mobile-fullscreen');
                
                this.handleFullscreenChange();
                this.showStatus('フルスクリーンモード開始', 'success');
            }
            
            async exitFullscreen() {
                if (this.isMobile() || this.isMobileFullscreen) {
                    this.exitMobileFullscreen();
                    return;
                }
                
                try {
                    if (document.exitFullscreen) {
                        await document.exitFullscreen();
                    } else if (document.webkitExitFullscreen) {
                        await document.webkitExitFullscreen();
                    } else if (document.mozCancelFullScreen) {
                        await document.mozCancelFullScreen();
                    } else if (document.msExitFullscreen) {
                        await document.msExitFullscreen();
                    }
                } catch (error) {
                    console.error('フルスクリーン終了エラー:', error);
                }
            }
            
            exitMobileFullscreen() {
                this.isMobileFullscreen = false;
                
                // スタイルを復元
                document.body.classList.remove('mobile-fullscreen-active');
                document.documentElement.classList.remove('mobile-fullscreen-active');
                this.videoWrapper.classList.remove('mobile-fullscreen');
                
                // ビューポートを復元
                if (this.originalViewport !== undefined) {
                    const viewport = document.querySelector('meta[name=viewport]');
                    if (viewport) {
                        viewport.content = this.originalViewport;
                    }
                }
                
                this.handleFullscreenChange();
                this.showStatus('通常表示に戻りました', 'success');
            }
            
            handleFullscreenChange() {
                const isFullscreen = this.isFullscreen();
                
                if (isFullscreen) {
                    this.fullscreenControls.style.display = 'flex';
                    this.fullscreenBtn.textContent = '📺 通常表示';
                    if (this.videoFullscreenBtn) {
                        this.videoFullscreenBtn.style.display = 'none';
                    }
                    this.updateFullscreenStats();
                } else {
                    this.fullscreenControls.style.display = 'none';
                    this.fullscreenBtn.textContent = '🔍 全画面表示';
                    if (this.videoFullscreenBtn && this.videoReady) {
                        this.videoFullscreenBtn.style.display = 'flex';
                    }
                }
            }
            
            updateFullscreenStats() {
                if (this.isFullscreen()) {
                    this.fsCurrentPeople.textContent = this.stats.currentPeople;
                    
                    if (this.isRecording && this.recordingStartTime) {
                        const elapsed = Math.floor((Date.now() - this.recordingStartTime) / 1000);
                        const minutes = Math.floor(elapsed / 60);
                        const seconds = elapsed % 60;
                        this.fsRecordingTime.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                        this.fsRecordingStatus.textContent = '記録中';
                    } else {
                        this.fsRecordingTime.textContent = '00:00';
                        this.fsRecordingStatus.textContent = '停止中';
                    }
                    
                    // フルスクリーン時のボタン状態を更新
                    this.fsRecordBtn.textContent = this.isRecording ? '⏹️ 記録停止' : '🔴 記録開始';
                    this.fsRecordBtn.disabled = !this.videoReady;
                    this.fsSwitchBtn.disabled = this.isDemoMode;
                }
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            const app = new PeopleFlowHeatmap();
            app.updateHeatmapOpacity();
        });
    </script>
</body>
</html>