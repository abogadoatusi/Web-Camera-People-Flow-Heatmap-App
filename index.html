<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äººæµãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ— - AIäººæ¤œå‡º</title>
    <!-- TensorFlow.js -->
    <script src="https://unpkg.com/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <!-- COCO-SSD ãƒ¢ãƒ‡ãƒ« -->
    <script src="https://unpkg.com/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.5rem;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
        }

        .btn-info {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .video-container {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
        }

        .video-wrapper {
            position: relative;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            background: #000;
        }

        video, canvas {
            display: block;
            width: 640px;
            height: 480px;
            max-width: 100%;
            border-radius: 15px;
        }

        #heatmapCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 2;
            opacity: 0.7;
        }

        .overlay-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 3;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .overlay-btn {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 15px;
            font-size: 12px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }

        .overlay-btn:hover {
            background: rgba(0, 0, 0, 0.9);
            transform: scale(1.05);
        }

        .opacity-slider {
            width: 100px;
            margin: 5px 0;
        }

        .label {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 14px;
            backdrop-filter: blur(5px);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #ffffff, #f8f9fa);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .legend {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 15px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid white;
        }

        .status {
            text-align: center;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 10px;
            font-weight: 600;
        }

        .status.success {
            background: linear-gradient(135deg, #d4edda, #c3e6cb);
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: linear-gradient(135deg, #f8d7da, #f5c6cb);
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            video, canvas {
                width: 100%;
                height: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”¥ äººæµãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—åˆ†æã‚·ã‚¹ãƒ†ãƒ </h1>
        
        <div id="status" class="status" style="display: none;"></div>
        
        <div class="controls">
            <button id="startBtn" class="btn btn-primary">ğŸ“¹ AIäººæ¤œå‡ºé–‹å§‹</button>
            <button id="demoBtn" class="btn btn-info">ğŸ¬ ãƒ‡ãƒ¢ãƒ¢ãƒ¼ãƒ‰</button>
            <button id="stopBtn" class="btn btn-secondary" disabled>â¹ï¸ åœæ­¢</button>
            <button id="resetBtn" class="btn btn-info">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
            <button id="recordBtn" class="btn btn-info" disabled>ğŸ”´ è¨˜éŒ²é–‹å§‹</button>
            <button id="playbackBtn" class="btn btn-info" disabled>â¯ï¸ ã‚¿ã‚¤ãƒ ãƒ©ãƒ—ã‚¹å†ç”Ÿ</button>
            <button id="downloadBtn" class="btn btn-info" disabled>ğŸ’¾ JSONä¿å­˜</button>
            <button id="downloadVideoBtn" class="btn btn-info" disabled>ğŸ¥ WebMå‹•ç”»ä¿å­˜</button>
        </div>

        <div class="video-container">
            <div class="video-wrapper">
                <video id="video" autoplay muted playsinline></video>
                <canvas id="heatmapCanvas"></canvas>
                <div class="label">ãƒ©ã‚¤ãƒ–æ˜ åƒ + AIäººæ¤œå‡ºãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—</div>
                <div class="overlay-controls">
                    <button id="toggleHeatmap" class="overlay-btn">ğŸ”¥ ON</button>
                    <input type="range" id="opacitySlider" class="opacity-slider" min="0" max="100" value="70">
                    <span style="color: white; font-size: 10px; text-align: center;">é€æ˜åº¦</span>
                </div>
            </div>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(0, 0, 255, 0.3);"></div>
                <span>ä½å¯†åº¦</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(0, 255, 0, 0.5);"></div>
                <span>ä¸­å¯†åº¦</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(255, 255, 0, 0.7);"></div>
                <span>é«˜å¯†åº¦</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(255, 0, 0, 0.8);"></div>
                <span>æœ€é«˜å¯†åº¦</span>
            </div>
        </div>

        <div class="stats">
            <div class="stat-card">
                <div id="totalDetections" class="stat-number">0</div>
                <div class="stat-label">ç·æ¤œå‡ºæ•°</div>
            </div>
            <div class="stat-card">
                <div id="currentPeople" class="stat-number">0</div>
                <div class="stat-label">ç¾åœ¨ã®äººæ•°</div>
            </div>
            <div class="stat-card">
                <div id="peakActivity" class="stat-number">0</div>
                <div class="stat-label">ãƒ”ãƒ¼ã‚¯æ´»å‹•</div>
            </div>
            <div class="stat-card">
                <div id="aiStatus" class="stat-number">èª­è¾¼ä¸­</div>
                <div class="stat-label">AIçŠ¶æ…‹</div>
            </div>
            <div class="stat-card">
                <div id="recordingTime" class="stat-number">00:00</div>
                <div class="stat-label">è¨˜éŒ²æ™‚é–“</div>
            </div>
            <div class="stat-card">
                <div id="recordedFrames" class="stat-number">0</div>
                <div class="stat-label">è¨˜éŒ²ãƒ•ãƒ¬ãƒ¼ãƒ </div>
            </div>
            <div class="stat-card">
                <div id="activeTime" class="stat-number">00:00</div>
                <div class="stat-label">ç¨¼åƒæ™‚é–“</div>
            </div>
        </div>
    </div>

    <script>
        class PeopleFlowHeatmap {
            constructor() {
                this.video = document.getElementById('video');
                this.canvas = document.getElementById('heatmapCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // çµ±è¨ˆè¦ç´ 
                this.totalDetections = document.getElementById('totalDetections');
                this.currentPeople = document.getElementById('currentPeople');
                this.peakActivity = document.getElementById('peakActivity');
                this.activeTime = document.getElementById('activeTime');
                this.aiStatus = document.getElementById('aiStatus');
                this.status = document.getElementById('status');
                
                // ãƒœã‚¿ãƒ³
                this.startBtn = document.getElementById('startBtn');
                this.demoBtn = document.getElementById('demoBtn');
                this.stopBtn = document.getElementById('stopBtn');
                this.resetBtn = document.getElementById('resetBtn');
                this.recordBtn = document.getElementById('recordBtn');
                this.playbackBtn = document.getElementById('playbackBtn');
                this.downloadBtn = document.getElementById('downloadBtn');
                this.downloadVideoBtn = document.getElementById('downloadVideoBtn');
                
                // è¨˜éŒ²é–¢é€£è¦ç´ 
                this.recordingTime = document.getElementById('recordingTime');
                this.recordedFrames = document.getElementById('recordedFrames');
                
                // UIè¦ç´ 
                this.toggleHeatmapBtn = document.getElementById('toggleHeatmap');
                this.opacitySlider = document.getElementById('opacitySlider');
                
                // ãƒ‡ãƒ¼ã‚¿ç®¡ç†
                this.heatmapData = {};
                this.animationId = null;
                this.stream = null;
                
                // ãƒ¢ãƒ¼ãƒ‰ç®¡ç†
                this.isDemoMode = false;
                this.demoCanvas = null;
                
                // ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—è¨­å®š
                this.heatmapEnabled = true;
                this.heatmapOpacity = 0.7;
                
                // çµ±è¨ˆ
                this.stats = {
                    totalDetections: 0,
                    currentPeople: 0,
                    peakActivity: 0,
                    startTime: null
                };
                
                // AIæ¤œå‡º
                this.model = null;
                this.modelLoaded = false;
                this.detectionCanvas = null;
                this.detectionCtx = null;
                
                // ã‚¿ã‚¤ãƒ ãƒ©ãƒ—ã‚¹è¨˜éŒ²
                this.isRecording = false;
                this.recordingStartTime = null;
                this.heatmapHistory = [];
                this.recordingInterval = 500;
                this.lastRecordTime = 0;
                this.playbackSpeed = 10;
                this.isPlayingBack = false;
                this.playbackIndex = 0;
                
                // å‹•ç”»è¨˜éŒ²ç”¨
                this.mediaRecorder = null;
                this.recordedChunks = [];
                this.videoFrames = [];
                this.cameraFrames = []; // ã‚«ãƒ¡ãƒ©æ˜ åƒãƒ•ãƒ¬ãƒ¼ãƒ è¿½åŠ 
                
                this.setupCanvas();
                this.loadAIModel();
                this.bindEvents();
                this.startStatsUpdater();
            }
            
            setupCanvas() {
                this.canvas.width = 640;
                this.canvas.height = 480;
                
                // AIæ¤œå‡ºç”¨ã®éš ã—ã‚­ãƒ£ãƒ³ãƒã‚¹
                this.detectionCanvas = document.createElement('canvas');
                this.detectionCanvas.width = 640;
                this.detectionCanvas.height = 480;
                this.detectionCtx = this.detectionCanvas.getContext('2d');
            }
            
            async loadAIModel() {
                try {
                    this.aiStatus.textContent = 'èª­è¾¼ä¸­...';
                    
                    // ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®èª­ã¿è¾¼ã¿å¾…æ©Ÿ
                    await this.waitForLibraries();
                    
                    // TensorFlow.jsã®åˆæœŸåŒ–ã‚’å¾…ã¤
                    console.log('TensorFlow.js loading...');
                    await tf.ready();
                    console.log('TensorFlow.js ready');
                    
                    // COCO-SSDãƒ¢ãƒ‡ãƒ«ã®èª­ã¿è¾¼ã¿
                    console.log('Loading COCO-SSD model...');
                    this.model = await cocoSsd.load();
                    this.modelLoaded = true;
                    this.aiStatus.textContent = 'æº–å‚™å®Œäº†';
                    this.aiStatus.style.color = '#4CAF50';
                    this.showStatus('AIäººæ¤œå‡ºãƒ¢ãƒ‡ãƒ«ãŒèª­ã¿è¾¼ã¾ã‚Œã¾ã—ãŸ', 'success');
                    console.log('COCO-SSD model loaded successfully');
                } catch (error) {
                    console.error('AI ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                    this.handleModelLoadError();
                }
            }
            
            async waitForLibraries() {
                const maxWait = 10000; // 10ç§’ã§ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
                const startTime = Date.now();
                
                return new Promise((resolve, reject) => {
                    const checkLibraries = () => {
                        if (typeof tf !== 'undefined' && typeof cocoSsd !== 'undefined') {
                            console.log('All libraries loaded successfully');
                            resolve();
                        } else if (Date.now() - startTime > maxWait) {
                            reject(new Error('Library loading timeout'));
                        } else {
                            console.log('Waiting for libraries...', {
                                tf: typeof tf !== 'undefined',
                                cocoSsd: typeof cocoSsd !== 'undefined'
                            });
                            setTimeout(checkLibraries, 500);
                        }
                    };
                    checkLibraries();
                });
            }
            
            handleModelLoadError() {
                this.aiStatus.textContent = 'ã‚ªãƒ•ãƒ©ã‚¤ãƒ³';
                this.aiStatus.style.color = '#ff9800';
                this.showStatus('AIãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã‚’ç¢ºèªã™ã‚‹ã‹ã€ãƒ‡ãƒ¢ãƒ¢ãƒ¼ãƒ‰ã‚’ãŠè©¦ã—ãã ã•ã„ã€‚', 'error');
                
                // AIãªã—ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆ
                this.startBtn.textContent = 'ğŸ“¹ ã‚«ãƒ¡ãƒ©é–‹å§‹ï¼ˆAIç„¡åŠ¹ï¼‰';
                this.startBtn.disabled = false;
            }
            
            bindEvents() {
                this.startBtn.addEventListener('click', () => this.startCamera());
                this.demoBtn.addEventListener('click', () => this.startDemo());
                this.stopBtn.addEventListener('click', () => this.stopCamera());
                this.resetBtn.addEventListener('click', () => this.resetData());
                this.recordBtn.addEventListener('click', () => this.toggleRecording());
                this.playbackBtn.addEventListener('click', () => this.startPlayback());
                this.downloadBtn.addEventListener('click', () => this.downloadData());
                this.downloadVideoBtn.addEventListener('click', () => this.downloadVideo());
                
                this.toggleHeatmapBtn.addEventListener('click', () => this.toggleHeatmap());
                this.opacitySlider.addEventListener('input', (e) => {
                    this.heatmapOpacity = e.target.value / 100;
                    this.updateHeatmapOpacity();
                });
            }
            
            showStatus(message, type = 'success') {
                this.status.textContent = message;
                this.status.className = `status ${type}`;
                this.status.style.display = 'block';
                
                setTimeout(() => {
                    this.status.style.display = 'none';
                }, 3000);
            }
            
            async startCamera() {
                try {
                    // ã¾ãšã‚«ãƒ¡ãƒ©ãƒ‡ãƒã‚¤ã‚¹ã®å­˜åœ¨ç¢ºèª
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const videoDevices = devices.filter(device => device.kind === 'videoinput');
                    
                    if (videoDevices.length === 0) {
                        throw new Error('ã‚«ãƒ¡ãƒ©ãƒ‡ãƒã‚¤ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ');
                    }
                    
                    this.showStatus('ã‚«ãƒ¡ãƒ©ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹è¨±å¯ã‚’æ±‚ã‚ã¦ã„ã¾ã™...', 'success');
                    
                    this.stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: { ideal: 640 },
                            height: { ideal: 480 },
                            facingMode: 'user'
                        }
                    });
                    
                    this.video.srcObject = this.stream;
                    this.stats.startTime = Date.now();
                    this.isDemoMode = false;
                    
                    this.video.addEventListener('loadedmetadata', () => {
                        this.startDetection();
                    });
                    
                    this.startBtn.disabled = true;
                    this.demoBtn.disabled = true;
                    this.stopBtn.disabled = false;
                    this.recordBtn.disabled = false;
                    
                    if (this.modelLoaded) {
                        this.showStatus('AIäººæ¤œå‡ºã‚«ãƒ¡ãƒ©ãŒé–‹å§‹ã•ã‚Œã¾ã—ãŸï¼', 'success');
                    } else {
                        this.showStatus('ã‚«ãƒ¡ãƒ©ãŒé–‹å§‹ã•ã‚Œã¾ã—ãŸï¼ˆAIæ©Ÿèƒ½ã¯ç„¡åŠ¹ï¼‰', 'success');
                    }
                } catch (error) {
                    console.error('ã‚«ãƒ¡ãƒ©ã‚¢ã‚¯ã‚»ã‚¹ã‚¨ãƒ©ãƒ¼:', error);
                    
                    let errorMessage = 'ã‚«ãƒ¡ãƒ©ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚';
                    
                    if (error.name === 'NotAllowedError') {
                        errorMessage = 'ã‚«ãƒ¡ãƒ©ã®ã‚¢ã‚¯ã‚»ã‚¹è¨±å¯ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã®è¨­å®šã§ã‚«ãƒ¡ãƒ©ã‚’è¨±å¯ã™ã‚‹ã‹ã€ãƒ‡ãƒ¢ãƒ¢ãƒ¼ãƒ‰ã‚’ãŠè©¦ã—ãã ã•ã„ã€‚';
                    } else if (error.name === 'NotFoundError') {
                        errorMessage = 'ã‚«ãƒ¡ãƒ©ãƒ‡ãƒã‚¤ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚ã‚«ãƒ¡ãƒ©ãŒæ¥ç¶šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚';
                    } else if (error.name === 'NotReadableError') {
                        errorMessage = 'ã‚«ãƒ¡ãƒ©ãŒä»–ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ä½¿ç”¨ä¸­ã§ã™ã€‚';
                    } else if (error.name === 'OverconstrainedError') {
                        errorMessage = 'ã‚«ãƒ¡ãƒ©ã®è¨­å®šã«å•é¡ŒãŒã‚ã‚Šã¾ã™ã€‚';
                    }
                    
                    this.showStatus(errorMessage, 'error');
                    
                    // 5ç§’å¾Œã«ãƒ‡ãƒ¢ãƒ¢ãƒ¼ãƒ‰ææ¡ˆ
                    setTimeout(() => {
                        this.showStatus('ã‚«ãƒ¡ãƒ©ãŒä½¿ç”¨ã§ããªã„å ´åˆã¯ã€ãƒ‡ãƒ¢ãƒ¢ãƒ¼ãƒ‰ã‚’ãŠè©¦ã—ãã ã•ã„', 'success');
                    }, 5000);
                }
            }
            
            startDemo() {
                this.isDemoMode = true;
                this.stats.startTime = Date.now();
                this.createDemoVideo();
                this.startDetection();
                
                this.startBtn.disabled = true;
                this.demoBtn.disabled = true;
                this.stopBtn.disabled = false;
                this.recordBtn.disabled = false;
                
                this.showStatus('ãƒ‡ãƒ¢ãƒ¢ãƒ¼ãƒ‰ãŒé–‹å§‹ã•ã‚Œã¾ã—ãŸï¼', 'success');
            }
            
            createDemoVideo() {
                const demoCanvas = document.createElement('canvas');
                demoCanvas.width = 640;
                demoCanvas.height = 480;
                const demoCtx = demoCanvas.getContext('2d');
                
                const gradient = demoCtx.createLinearGradient(0, 0, 640, 480);
                gradient.addColorStop(0, '#e3f2fd');
                gradient.addColorStop(1, '#bbdefb');
                demoCtx.fillStyle = gradient;
                demoCtx.fillRect(0, 0, 640, 480);
                
                demoCtx.fillStyle = '#1976d2';
                demoCtx.font = 'bold 24px Arial';
                demoCtx.textAlign = 'center';
                demoCtx.fillText('ãƒ‡ãƒ¢ãƒ¢ãƒ¼ãƒ‰ - ä»®æƒ³ç©ºé–“', 320, 50);
                
                this.video.style.display = 'none';
                const imgElement = document.createElement('img');
                imgElement.src = demoCanvas.toDataURL();
                imgElement.style.position = 'absolute';
                imgElement.style.top = '0';
                imgElement.style.left = '0';
                imgElement.style.zIndex = '1';
                this.video.parentNode.insertBefore(imgElement, this.video);
                this.demoCanvas = imgElement;
            }
            
            stopCamera() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
                
                if (this.demoCanvas) {
                    this.demoCanvas.remove();
                    this.demoCanvas = null;
                }
                
                this.video.style.display = 'block';
                this.isDemoMode = false;
                
                if (this.isRecording) {
                    this.stopRecording();
                }
                
                this.startBtn.disabled = false;
                this.demoBtn.disabled = false;
                this.stopBtn.disabled = true;
                this.recordBtn.disabled = true;
                
                if (this.heatmapHistory.length > 0) {
                    this.playbackBtn.disabled = false;
                    this.downloadBtn.disabled = false;
                    this.downloadVideoBtn.disabled = false;
                }
                
                this.showStatus('åœæ­¢ã•ã‚Œã¾ã—ãŸ', 'success');
            }
            
            resetData() {
                this.heatmapData = {};
                this.heatmapHistory = [];
                this.stats = {
                    totalDetections: 0,
                    currentPeople: 0,
                    peakActivity: 0,
                    startTime: this.stats.startTime
                };
                
                this.isRecording = false;
                this.recordingStartTime = null;
                this.isPlayingBack = false;
                this.playbackIndex = 0;
                
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.updateStatsDisplay();
                
                this.recordBtn.textContent = 'ğŸ”´ è¨˜éŒ²é–‹å§‹';
                this.recordBtn.disabled = !this.isDemoMode;
                this.playbackBtn.disabled = true;
                this.downloadBtn.disabled = true;
                this.downloadVideoBtn.disabled = true;
                
                this.showStatus('ãƒ‡ãƒ¼ã‚¿ãŒãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã—ãŸ', 'success');
            }
            
            toggleHeatmap() {
                this.heatmapEnabled = !this.heatmapEnabled;
                this.toggleHeatmapBtn.textContent = this.heatmapEnabled ? 'ğŸ”¥ ON' : 'ğŸ”¥ OFF';
                this.updateHeatmapOpacity();
            }
            
            updateHeatmapOpacity() {
                if (this.heatmapEnabled) {
                    this.canvas.style.opacity = this.heatmapOpacity;
                    this.canvas.style.display = 'block';
                } else {
                    this.canvas.style.display = 'none';
                }
            }
            
            toggleRecording() {
                if (!this.isRecording) {
                    this.startRecording();
                } else {
                    this.stopRecording();
                }
            }
            
            startRecording() {
                this.isRecording = true;
                this.recordingStartTime = Date.now();
                this.heatmapHistory = [];
                this.videoFrames = [];
                this.cameraFrames = []; // ã‚«ãƒ¡ãƒ©ãƒ•ãƒ¬ãƒ¼ãƒ ã‚‚åˆæœŸåŒ–
                this.lastRecordTime = 0;
                
                this.recordBtn.textContent = 'â¹ï¸ è¨˜éŒ²åœæ­¢';
                this.showStatus('äººæµãƒ‡ãƒ¼ã‚¿ã¨æ˜ åƒã®è¨˜éŒ²ã‚’é–‹å§‹ã—ã¾ã—ãŸ', 'success');
            }
            
            stopRecording() {
                this.isRecording = false;
                this.recordBtn.textContent = 'ğŸ”´ è¨˜éŒ²é–‹å§‹';
                
                if (this.heatmapHistory.length > 0) {
                    this.playbackBtn.disabled = false;
                    this.downloadBtn.disabled = false;
                    this.downloadVideoBtn.disabled = false;
                    
                    const cameraFrameCount = this.cameraFrames.length;
                    const heatmapFrameCount = this.heatmapHistory.length;
                    
                    this.showStatus(`è¨˜éŒ²å®Œäº†ï¼ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—:${heatmapFrameCount}ãƒ•ãƒ¬ãƒ¼ãƒ ã€ã‚«ãƒ¡ãƒ©:${cameraFrameCount}ãƒ•ãƒ¬ãƒ¼ãƒ `, 'success');
                } else {
                    this.showStatus('è¨˜éŒ²ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“', 'error');
                }
            }
            
            recordHeatmapFrame() {
                if (!this.isRecording) return;
                
                const currentTime = Date.now();
                if (currentTime - this.lastRecordTime < this.recordingInterval) return;
                
                const frameData = {
                    timestamp: currentTime - this.recordingStartTime,
                    heatmapData: JSON.parse(JSON.stringify(this.heatmapData)),
                    stats: {
                        currentPeople: this.stats.currentPeople,
                        totalDetections: this.stats.totalDetections
                    }
                };
                
                this.heatmapHistory.push(frameData);
                this.lastRecordTime = currentTime;
                
                this.recordVideoFrame();
            }
            
            recordVideoFrame() {
                // ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ç”»åƒãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
                const heatmapImageData = this.canvas.toDataURL('image/png');
                this.videoFrames.push({
                    timestamp: Date.now() - this.recordingStartTime,
                    imageData: heatmapImageData
                });
            }
            
            recordCameraFrame() {
                if (!this.isDemoMode && this.video.readyState === this.video.HAVE_ENOUGH_DATA) {
                    // å®Ÿéš›ã®ã‚«ãƒ¡ãƒ©æ˜ åƒã‚’ã‚­ãƒ£ãƒ³ãƒã‚¹ã«æç”»ã—ã¦ä¿å­˜
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = 640;
                    tempCanvas.height = 480;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    // ãƒ“ãƒ‡ã‚ªã‚’ã‚­ãƒ£ãƒ³ãƒã‚¹ã«æç”»
                    tempCtx.drawImage(this.video, 0, 0, 640, 480);
                    
                    const cameraImageData = tempCanvas.toDataURL('image/png');
                    this.cameraFrames.push({
                        timestamp: Date.now() - this.recordingStartTime,
                        imageData: cameraImageData
                    });
                    
                    console.log(`ã‚«ãƒ¡ãƒ©ãƒ•ãƒ¬ãƒ¼ãƒ  ${this.cameraFrames.length} ã‚’è¨˜éŒ²ã—ã¾ã—ãŸ`);
                    
                } else if (this.isDemoMode && this.demoCanvas) {
                    // ãƒ‡ãƒ¢ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã¯èƒŒæ™¯ç”»åƒã‚’ä¿å­˜
                    this.cameraFrames.push({
                        timestamp: Date.now() - this.recordingStartTime,
                        imageData: this.demoCanvas.src
                    });
                    
                    console.log(`ãƒ‡ãƒ¢ãƒ•ãƒ¬ãƒ¼ãƒ  ${this.cameraFrames.length} ã‚’è¨˜éŒ²ã—ã¾ã—ãŸ`);
                } else {
                    console.warn('ã‚«ãƒ¡ãƒ©ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’è¨˜éŒ²ã§ãã¾ã›ã‚“ã§ã—ãŸ - ãƒ“ãƒ‡ã‚ªæº–å‚™æœªå®Œäº†');
                }
            }
            
            startPlayback() {
                if (this.heatmapHistory.length === 0) {
                    this.showStatus('å†ç”Ÿã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“', 'error');
                    return;
                }
                
                this.isPlayingBack = true;
                this.playbackIndex = 0;
                this.playbackBtn.textContent = 'â¸ï¸ å†ç”Ÿåœæ­¢';
                this.playbackBtn.disabled = false;
                
                this.showStatus('ã‚¿ã‚¤ãƒ ãƒ©ãƒ—ã‚¹å†ç”Ÿã‚’é–‹å§‹ã—ã¾ã™', 'success');
                this.playHeatmapHistory();
            }
            
            stopPlayback() {
                this.isPlayingBack = false;
                this.playbackBtn.textContent = 'â¯ï¸ ã‚¿ã‚¤ãƒ ãƒ©ãƒ—ã‚¹å†ç”Ÿ';
                
                if (this.heatmapHistory.length > 0) {
                    const lastFrame = this.heatmapHistory[this.heatmapHistory.length - 1];
                    this.heatmapData = lastFrame.heatmapData;
                    this.updateHeatmap();
                }
            }
            
            playHeatmapHistory() {
                if (!this.isPlayingBack || this.playbackIndex >= this.heatmapHistory.length) {
                    this.stopPlayback();
                    return;
                }
                
                const frame = this.heatmapHistory[this.playbackIndex];
                this.heatmapData = frame.heatmapData;
                this.updateHeatmap();
                
                const minutes = Math.floor(frame.timestamp / 60000);
                const seconds = Math.floor((frame.timestamp % 60000) / 1000);
                this.showStatus(`ã‚¿ã‚¤ãƒ ãƒ©ãƒ—ã‚¹å†ç”Ÿä¸­: ${minutes}:${seconds.toString().padStart(2, '0')} (${this.playbackIndex + 1}/${this.heatmapHistory.length})`, 'success');
                
                this.playbackIndex++;
                
                setTimeout(() => {
                    this.playHeatmapHistory();
                }, this.recordingInterval / this.playbackSpeed);
            }
            
            downloadData() {
                if (this.heatmapHistory.length === 0) {
                    this.showStatus('ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“', 'error');
                    return;
                }
                
                const exportData = {
                    metadata: {
                        recordingDate: new Date().toISOString(),
                        totalFrames: this.heatmapHistory.length,
                        recordingDuration: this.heatmapHistory[this.heatmapHistory.length - 1].timestamp,
                        recordingInterval: this.recordingInterval
                    },
                    frames: this.heatmapHistory
                };
                
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `people-flow-data-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                this.showStatus('äººæµãƒ‡ãƒ¼ã‚¿ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸ', 'success');
            }
            
            async downloadVideo() {
                if (this.videoFrames.length === 0) {
                    this.showStatus('å‹•ç”»ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“', 'error');
                    return;
                }
                
                // ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’è¡¨ç¤º
                console.log('å‹•ç”»ç”Ÿæˆé–‹å§‹:');
                console.log('- ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—ãƒ•ãƒ¬ãƒ¼ãƒ æ•°:', this.videoFrames.length);
                console.log('- ã‚«ãƒ¡ãƒ©ãƒ•ãƒ¬ãƒ¼ãƒ æ•°:', this.cameraFrames.length);
                console.log('- ãƒ‡ãƒ¢ãƒ¢ãƒ¼ãƒ‰:', this.isDemoMode);
                
                this.showStatus(`WebMå‹•ç”»ã‚’ç”Ÿæˆä¸­... (${this.videoFrames.length}ãƒ•ãƒ¬ãƒ¼ãƒ )`, 'success');
                
                try {
                    // ã‚·ãƒ³ãƒ—ãƒ«ãªã‚­ãƒ£ãƒ³ãƒã‚¹ãƒ™ãƒ¼ã‚¹ã®å‹•ç”»ç”Ÿæˆ
                    const canvas = document.createElement('canvas');
                    canvas.width = 640;
                    canvas.height = 480;
                    const ctx = canvas.getContext('2d');
                    
                    // MediaRecorderè¨­å®š
                    const stream = canvas.captureStream(10); // 10fps
                    const mediaRecorder = new MediaRecorder(stream, {
                        mimeType: 'video/webm'
                    });
                    
                    const recordedChunks = [];
                    
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            recordedChunks.push(event.data);
                            console.log('ãƒ‡ãƒ¼ã‚¿ãƒãƒ£ãƒ³ã‚¯ã‚’å—ä¿¡:', event.data.size, 'bytes');
                        }
                    };
                    
                    mediaRecorder.onstop = () => {
                        console.log('éŒ²ç”»åœæ­¢ã€‚ç·ãƒãƒ£ãƒ³ã‚¯æ•°:', recordedChunks.length);
                        const blob = new Blob(recordedChunks, { type: 'video/webm' });
                        console.log('å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º:', blob.size, 'bytes');
                        
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `people-flow-heatmap-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.webm`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        
                        this.showStatus('WebMå‹•ç”»ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸ', 'success');
                    };
                    
                    // éŒ²ç”»é–‹å§‹
                    mediaRecorder.start();
                    console.log('éŒ²ç”»é–‹å§‹');
                    
                    // ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æç”»
                    const frameCount = Math.min(this.videoFrames.length, this.cameraFrames.length);
                    console.log('å‡¦ç†ã™ã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ æ•°:', frameCount);
                    
                    for (let i = 0; i < this.videoFrames.length; i++) {
                        try {
                            // èƒŒæ™¯ã‚’ã‚¯ãƒªã‚¢
                            ctx.fillStyle = '#f0f0f0';
                            ctx.fillRect(0, 0, 640, 480);
                            
                            let cameraDrawn = false;
                            
                            // ã‚«ãƒ¡ãƒ©æ˜ åƒã‚’å…ˆã«æç”»
                            if (this.cameraFrames && this.cameraFrames[i]) {
                                console.log(`ãƒ•ãƒ¬ãƒ¼ãƒ  ${i}: ã‚«ãƒ¡ãƒ©æ˜ åƒã‚’æç”»ä¸­`);
                                const cameraImg = new Image();
                                
                                await new Promise((resolve) => {
                                    cameraImg.onload = () => {
                                        ctx.drawImage(cameraImg, 0, 0, 640, 480);
                                        cameraDrawn = true;
                                        console.log(`ãƒ•ãƒ¬ãƒ¼ãƒ  ${i}: ã‚«ãƒ¡ãƒ©æ˜ åƒæç”»å®Œäº†`);
                                        resolve();
                                    };
                                    cameraImg.onerror = () => {
                                        console.error(`ãƒ•ãƒ¬ãƒ¼ãƒ  ${i}: ã‚«ãƒ¡ãƒ©ç”»åƒèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼`);
                                        resolve();
                                    };
                                    cameraImg.src = this.cameraFrames[i].imageData;
                                });
                            } else {
                                console.log(`ãƒ•ãƒ¬ãƒ¼ãƒ  ${i}: ã‚«ãƒ¡ãƒ©ãƒ•ãƒ¬ãƒ¼ãƒ ãªã—`);
                            }
                            
                            // ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—ã‚’é‡ã­åˆã‚ã›
                            const frame = this.videoFrames[i];
                            const heatmapImg = new Image();
                            
                            await new Promise((resolve) => {
                                heatmapImg.onload = () => {
                                    ctx.globalAlpha = 0.7;
                                    ctx.drawImage(heatmapImg, 0, 0, 640, 480);
                                    ctx.globalAlpha = 1.0;
                                    console.log(`ãƒ•ãƒ¬ãƒ¼ãƒ  ${i}: ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—æç”»å®Œäº†`);
                                    resolve();
                                };
                                heatmapImg.onerror = () => {
                                    console.error(`ãƒ•ãƒ¬ãƒ¼ãƒ  ${i}: ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—ç”»åƒèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼`);
                                    resolve();
                                };
                                heatmapImg.src = frame.imageData;
                            });
                            
                            // æƒ…å ±è¡¨ç¤º
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                            ctx.fillRect(10, 10, 250, 80);
                            ctx.fillStyle = 'white';
                            ctx.font = 'bold 16px Arial';
                            ctx.fillText(`Frame: ${i + 1}/${this.videoFrames.length}`, 20, 35);
                            ctx.fillText(`Time: ${Math.floor(frame.timestamp / 1000)}s`, 20, 55);
                            
                            if (cameraDrawn) {
                                ctx.fillStyle = 'lime';
                                ctx.fillText('ğŸ“¹ Camera: ON', 20, 75);
                            } else {
                                ctx.fillStyle = 'red';
                                ctx.fillText('ğŸ“¹ Camera: OFF', 20, 75);
                            }
                            
                            // é€²æ—è¡¨ç¤º
                            const progress = Math.round((i / this.videoFrames.length) * 100);
                            this.showStatus(`å‹•ç”»ç”Ÿæˆä¸­... ${progress}% (${i + 1}/${this.videoFrames.length})`, 'success');
                            
                        } catch (error) {
                            console.error(`ãƒ•ãƒ¬ãƒ¼ãƒ  ${i} å‡¦ç†ã‚¨ãƒ©ãƒ¼:`, error);
                        }
                        
                        // ãƒ•ãƒ¬ãƒ¼ãƒ é–“ã®å¾…æ©Ÿï¼ˆé‡è¦ï¼‰
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                    
                    // éŒ²ç”»åœæ­¢
                    console.log('éŒ²ç”»åœæ­¢ã‚’å®Ÿè¡Œ');
                    setTimeout(() => {
                        mediaRecorder.stop();
                        stream.getTracks().forEach(track => track.stop());
                    }, 500);
                    
                } catch (error) {
                    console.error('WebMå‹•ç”»ç”Ÿæˆã‚¨ãƒ©ãƒ¼:', error);
                    this.showStatus('WebMç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
                }
            }
            
            async downloadSimpleVideo() {
                try {
                    const canvas = document.createElement('canvas');
                    canvas.width = 640;
                    canvas.height = 480;
                    const ctx = canvas.getContext('2d');
                    
                    const stream = canvas.captureStream(10);
                    const mediaRecorder = new MediaRecorder(stream);
                    
                    const chunks = [];
                    mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
                    mediaRecorder.onstop = () => {
                        const blob = new Blob(chunks, { type: 'video/webm' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `heatmap-simple-${Date.now()}.webm`;
                        a.click();
                        URL.revokeObjectURL(url);
                        this.showStatus('ã‚·ãƒ³ãƒ—ãƒ«å‹•ç”»ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸ', 'success');
                    };
                    
                    mediaRecorder.start();
                    
                    for (const frame of this.videoFrames) {
                        const img = new Image();
                        await new Promise(resolve => {
                            img.onload = () => {
                                ctx.clearRect(0, 0, 640, 480);
                                ctx.drawImage(img, 0, 0);
                                resolve();
                            };
                            img.src = frame.imageData;
                        });
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                    
                    setTimeout(() => mediaRecorder.stop(), 200);
                    
                } catch (error) {
                    console.error('ã‚·ãƒ³ãƒ—ãƒ«å‹•ç”»ç”Ÿæˆã‚‚ã‚¨ãƒ©ãƒ¼:', error);
                    this.showStatus('å‹•ç”»ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ–ãƒ©ã‚¦ã‚¶ãŒWebMéŒ²ç”»ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚', 'error');
                }
            }
            
            async downloadFramesAsImages() {
                this.showStatus('ç”»åƒãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ç”Ÿæˆä¸­...', 'success');
                
                const frameCount = Math.min(this.videoFrames.length, this.cameraFrames.length);
                
                // åˆæˆã•ã‚ŒãŸç”»åƒãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ä½œæˆ
                for (let i = 0; i < Math.min(frameCount, 20); i++) { // æœ€å¤§20ãƒ•ãƒ¬ãƒ¼ãƒ 
                    try {
                        const compositeCanvas = document.createElement('canvas');
                        compositeCanvas.width = 640;
                        compositeCanvas.height = 480;
                        const compositeCtx = compositeCanvas.getContext('2d');
                        
                        // ã‚«ãƒ¡ãƒ©æ˜ åƒã‚’æç”»
                        if (this.cameraFrames[i]) {
                            const cameraImg = new Image();
                            await new Promise((resolve, reject) => {
                                cameraImg.onload = () => {
                                    compositeCtx.drawImage(cameraImg, 0, 0, 640, 480);
                                    resolve();
                                };
                                cameraImg.onerror = reject;
                                cameraImg.src = this.cameraFrames[i].imageData;
                            });
                        }
                        
                        // ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—ã‚’é‡ã­ã‚‹
                        if (this.videoFrames[i]) {
                            const heatmapImg = new Image();
                            await new Promise((resolve, reject) => {
                                heatmapImg.onload = () => {
                                    compositeCtx.globalAlpha = this.heatmapOpacity;
                                    compositeCtx.drawImage(heatmapImg, 0, 0, 640, 480);
                                    compositeCtx.globalAlpha = 1.0;
                                    resolve();
                                };
                                heatmapImg.onerror = reject;
                                heatmapImg.src = this.videoFrames[i].imageData;
                            });
                        }
                        
                        // ãƒ•ãƒ¬ãƒ¼ãƒ æƒ…å ±ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤
                        compositeCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        compositeCtx.fillRect(10, 10, 200, 60);
                        compositeCtx.fillStyle = 'white';
                        compositeCtx.font = '14px Arial';
                        compositeCtx.fillText(`ãƒ•ãƒ¬ãƒ¼ãƒ : ${i + 1}/${frameCount}`, 20, 30);
                        
                        const timestamp = this.videoFrames[i]?.timestamp || 0;
                        const minutes = Math.floor(timestamp / 60000);
                        const seconds = Math.floor((timestamp % 60000) / 1000);
                        compositeCtx.fillText(`æ™‚é–“: ${minutes}:${seconds.toString().padStart(2, '0')}`, 20, 50);
                        
                        // ç”»åƒã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                        const link = document.createElement('a');
                        link.download = `people-flow-frame-${(i + 1).toString().padStart(3, '0')}.png`;
                        link.href = compositeCanvas.toDataURL('image/png');
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        
                        // å°‘ã—å¾…æ©Ÿ
                        await new Promise(resolve => setTimeout(resolve, 200));
                        
                    } catch (error) {
                        console.error(`ãƒ•ãƒ¬ãƒ¼ãƒ  ${i} ã®ç”Ÿæˆã«å¤±æ•—:`, error);
                    }
                }
                
                this.showStatus(`${Math.min(frameCount, 20)}å€‹ã®åˆæˆç”»åƒãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸ`, 'success');
                
                // GIFã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä½œæˆã®æ¡ˆå†…
                setTimeout(() => {
                    this.showStatus('ç”»åƒãƒ•ãƒ¬ãƒ¼ãƒ ã‚’GIFã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã«å¤‰æ›ã™ã‚‹ã«ã¯ã€ã‚ªãƒ³ãƒ©ã‚¤ãƒ³GIFä½œæˆãƒ„ãƒ¼ãƒ«ã‚’ã”åˆ©ç”¨ãã ã•ã„', 'success');
                }, 3000);
            }
            
            downloadSeparateVideos() {
                // ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—ã®ã¿ã®å‹•ç”»
                this.downloadHeatmapVideo();
                
                // ã‚«ãƒ¡ãƒ©æ˜ åƒã®ã¿ã®ç”»åƒ
                this.downloadCameraFrames();
            }
            
            async downloadHeatmapVideo() {
                try {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = 640;
                    tempCanvas.height = 480;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    const stream = tempCanvas.captureStream(10);
                    const mediaRecorder = new MediaRecorder(stream, {
                        mimeType: 'video/webm'
                    });
                    
                    const chunks = [];
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            chunks.push(event.data);
                        }
                    };
                    
                    mediaRecorder.onstop = () => {
                        const blob = new Blob(chunks, { type: 'video/webm' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `people-flow-heatmap-only-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.webm`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    };
                    
                    mediaRecorder.start();
                    
                    for (let i = 0; i < this.videoFrames.length; i++) {
                        const frame = this.videoFrames[i];
                        const img = new Image();
                        
                        await new Promise((resolve) => {
                            img.onload = () => {
                                tempCtx.clearRect(0, 0, 640, 480);
                                tempCtx.drawImage(img, 0, 0);
                                resolve();
                            };
                            img.src = frame.imageData;
                        });
                        
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                    
                    mediaRecorder.stop();
                } catch (error) {
                    console.error('ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—å‹•ç”»ç”Ÿæˆã‚¨ãƒ©ãƒ¼:', error);
                }
            }
            
            downloadCameraFrames() {
                // ã‚«ãƒ¡ãƒ©ãƒ•ãƒ¬ãƒ¼ãƒ ã®æœ€åˆã®ç”»åƒã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                if (this.cameraFrames.length > 0) {
                    const firstFrame = this.cameraFrames[0];
                    const a = document.createElement('a');
                    a.href = firstFrame.imageData;
                    a.download = `camera-sample-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.png`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                }
            }
            
            startDetection() {
                const detect = async () => {
                    if (this.isDemoMode && !this.isPlayingBack) {
                        // ãƒ‡ãƒ¢ãƒ¢ãƒ¼ãƒ‰ã¯å¾“æ¥é€šã‚Š
                        this.detectMotion();
                        this.updateHeatmap();
                        this.recordHeatmapFrame();
                    } else if (this.video.readyState === this.video.HAVE_ENOUGH_DATA && !this.isPlayingBack) {
                        if (this.modelLoaded) {
                            // AIæ¤œå‡ºãƒ¢ãƒ¼ãƒ‰
                            await this.detectPeopleWithAI();
                        } else {
                            // AIãªã—ãƒ¢ãƒ¼ãƒ‰ï¼ˆåŸºæœ¬çš„ãªå‹•ãæ¤œå‡ºï¼‰
                            this.detectMotion();
                        }
                        this.updateHeatmap();
                        this.recordHeatmapFrame();
                    }
                    this.animationId = requestAnimationFrame(detect);
                };
                detect();
            }
            
            detectMotion() {
                const currentTime = Date.now();
                const mockDetections = this.generateMockDetections();
                
                this.stats.currentPeople = mockDetections.length;
                this.stats.totalDetections += mockDetections.length;
                
                if (mockDetections.length > this.stats.peakActivity) {
                    this.stats.peakActivity = mockDetections.length;
                }
                
                mockDetections.forEach(detection => {
                    const key = `${Math.floor(detection.x / 20)}_${Math.floor(detection.y / 20)}`;
                    if (!this.heatmapData[key]) {
                        this.heatmapData[key] = {
                            count: 0,
                            x: Math.floor(detection.x / 20) * 20,
                            y: Math.floor(detection.y / 20) * 20,
                            lastUpdate: currentTime
                        };
                    }
                    this.heatmapData[key].count++;
                    this.heatmapData[key].lastUpdate = currentTime;
                });
                
                // æ”¹å–„ã•ã‚ŒãŸæ¸›è¡°å‡¦ç†
                Object.keys(this.heatmapData).forEach(key => {
                    const data = this.heatmapData[key];
                    const timeDiff = currentTime - data.lastUpdate;
                    if (timeDiff > 3000) {
                        const decayFactor = Math.max(0, 1 - (timeDiff - 3000) / 10000);
                        data.count *= decayFactor;
                        
                        if (data.count <= 0.1) {
                            delete this.heatmapData[key];
                        }
                    }
                });
            }
            
            generateMockDetections() {
                const detections = [];
                const time = (Date.now() - this.stats.startTime) / 1000;
                const timeOfDay = (time % 60) / 60;
                const baseActivity = Math.sin(timeOfDay * Math.PI * 2) * 0.5 + 0.5;
                const numPeople = Math.floor(baseActivity * 12) + 2;
                
                const hotspots = [
                    { x: 160, y: 200 },
                    { x: 480, y: 200 },
                    { x: 320, y: 350 },
                    { x: 100, y: 400 }
                ];
                
                for (let i = 0; i < numPeople; i++) {
                    const hotspot = hotspots[Math.floor(Math.random() * hotspots.length)];
                    const spreadRadius = 80;
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * spreadRadius;
                    
                    const x = Math.max(50, Math.min(590, hotspot.x + Math.cos(angle) * distance));
                    const y = Math.max(150, Math.min(430, hotspot.y + Math.sin(angle) * distance));
                    
                    detections.push({ x, y });
                }
                
                return detections;
            }
            
            updateHeatmap() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                Object.values(this.heatmapData).forEach(point => {
                    const intensity = Math.min(point.count / 20, 1);
                    
                    let r, g, b;
                    if (intensity < 0.25) {
                        r = 0; 
                        g = 0; 
                        b = Math.floor(255 * intensity * 4);
                    } else if (intensity < 0.5) {
                        r = 0; 
                        g = Math.floor(255 * (intensity - 0.25) * 4); 
                        b = 255 - g;
                    } else if (intensity < 0.75) {
                        r = Math.floor(255 * (intensity - 0.5) * 4); 
                        g = 255; 
                        b = 0;
                    } else {
                        r = 255; 
                        g = 255 - Math.floor(255 * (intensity - 0.75) * 4); 
                        b = 0;
                    }
                    
                    const alpha = intensity * 0.6;
                    const gradient = this.ctx.createRadialGradient(point.x, point.y, 0, point.x, point.y, 40);
                    gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${alpha})`);
                    gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(point.x, point.y, 40, 0, Math.PI * 2);
                    this.ctx.fill();
                });
            }
            
            startStatsUpdater() {
                setInterval(() => {
                    this.updateStatsDisplay();
                }, 1000);
            }
            
            updateStatsDisplay() {
                this.totalDetections.textContent = this.stats.totalDetections.toLocaleString();
                this.currentPeople.textContent = this.stats.currentPeople;
                this.peakActivity.textContent = this.stats.peakActivity;
                
                if (this.stats.startTime) {
                    const elapsedTime = Math.floor((Date.now() - this.stats.startTime) / 1000);
                    const minutes = Math.floor(elapsedTime / 60);
                    const seconds = elapsedTime % 60;
                    this.activeTime.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
                
                // è¨˜éŒ²æ™‚é–“ã¨ãƒ•ãƒ¬ãƒ¼ãƒ æ•°ã®æ›´æ–°
                if (this.isRecording && this.recordingStartTime) {
                    const recordTime = Math.floor((Date.now() - this.recordingStartTime) / 1000);
                    const recordMinutes = Math.floor(recordTime / 60);
                    const recordSeconds = recordTime % 60;
                    this.recordingTime.textContent = `${recordMinutes.toString().padStart(2, '0')}:${recordSeconds.toString().padStart(2, '0')}`;
                } else if (!this.isRecording && this.heatmapHistory.length > 0) {
                    const totalDuration = Math.floor(this.heatmapHistory[this.heatmapHistory.length - 1].timestamp / 1000);
                    const totalMinutes = Math.floor(totalDuration / 60);
                    const totalSeconds = totalDuration % 60;
                    this.recordingTime.textContent = `${totalMinutes.toString().padStart(2, '0')}:${totalSeconds.toString().padStart(2, '0')}`;
                } else {
                    this.recordingTime.textContent = '00:00';
                }
                
                this.recordedFrames.textContent = this.heatmapHistory.length;
                
                // AIçŠ¶æ…‹ã®æ›´æ–°
                if (!this.aiStatus.textContent.includes('æº–å‚™å®Œäº†') && !this.aiStatus.textContent.includes('ã‚¨ãƒ©ãƒ¼') && !this.aiStatus.textContent.includes('ã‚ªãƒ•ãƒ©ã‚¤ãƒ³')) {
                    if (this.modelLoaded) {
                        this.aiStatus.textContent = 'æº–å‚™å®Œäº†';
                        this.aiStatus.style.color = '#4CAF50';
                    }
                }
            }
            
            async detectPeopleWithAI() {
                try {
                    // ãƒ“ãƒ‡ã‚ªãƒ•ãƒ¬ãƒ¼ãƒ ã‚’éš ã—ã‚­ãƒ£ãƒ³ãƒã‚¹ã«æç”»
                    this.detectionCtx.drawImage(this.video, 0, 0, 640, 480);
                    
                    // AI ã«ã‚ˆã‚‹ç‰©ä½“æ¤œå‡º
                    const predictions = await this.model.detect(this.detectionCanvas);
                    
                    // äººã®ã¿ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
                    const people = predictions.filter(prediction => 
                        prediction.class === 'person' && prediction.score > 0.5
                    );
                    
                    // æ¤œå‡ºã•ã‚ŒãŸäººã®ä¸­å¿ƒç‚¹ã‚’è¨ˆç®—
                    const detections = people.map(person => {
                        const [x, y, width, height] = person.bbox;
                        return {
                            x: x + width / 2,
                            y: y + height / 2,
                            confidence: person.score,
                            bbox: person.bbox
                        };
                    });
                    
                    // çµ±è¨ˆæ›´æ–°
                    this.stats.currentPeople = detections.length;
                    this.stats.totalDetections += detections.length;
                    
                    if (detections.length > this.stats.peakActivity) {
                        this.stats.peakActivity = detections.length;
                    }
                    
                    // ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿æ›´æ–°
                    this.updateHeatmapData(detections);
                    
                    // æ¤œå‡ºçµæœã‚’ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«å‡ºåŠ›ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
                    if (detections.length > 0) {
                        console.log(`${detections.length}äººã‚’æ¤œå‡ºã—ã¾ã—ãŸ`);
                    }
                    
                } catch (error) {
                    console.error('AIæ¤œå‡ºã‚¨ãƒ©ãƒ¼:', error);
                }
            }
            
            updateHeatmapData(detections) {
                const currentTime = Date.now();
                
                // æ¤œå‡ºãƒ‡ãƒ¼ã‚¿ã‚’ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—ã«è¿½åŠ 
                detections.forEach(detection => {
                    const key = `${Math.floor(detection.x / 20)}_${Math.floor(detection.y / 20)}`;
                    if (!this.heatmapData[key]) {
                        this.heatmapData[key] = {
                            count: 0,
                            x: Math.floor(detection.x / 20) * 20,
                            y: Math.floor(detection.y / 20) * 20,
                            lastUpdate: currentTime
                        };
                    }
                    this.heatmapData[key].count += detection.confidence || 1;
                    this.heatmapData[key].lastUpdate = currentTime;
                });
                
                // å¤ã„ãƒ‡ãƒ¼ã‚¿ã®æ¸›è¡°å‡¦ç†
                Object.keys(this.heatmapData).forEach(key => {
                    const data = this.heatmapData[key];
                    const timeDiff = currentTime - data.lastUpdate;
                    if (timeDiff > 10000) { // 10ç§’å¾Œã«æ¸›è¡°é–‹å§‹
                        data.count = Math.max(0, data.count - 0.05);
                        if (data.count <= 0) {
                            delete this.heatmapData[key];
                        }
                    }
                });
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            const app = new PeopleFlowHeatmap();
            app.updateHeatmapOpacity();
        });
    </script>
</body>
</html>